<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Asciidoctor 0.1.4">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fermat Documentation</title>
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }
audio, canvas, video { display: inline-block; }
audio:not([controls]) { display: none; height: 0; }
[hidden] { display: none; }
html { background: #fff; color: #000; font-family: sans-serif; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; }
body { margin: 0; }
a:focus { outline: thin dotted; }
a:active, a:hover { outline: 0; }
h1 { font-size: 2em; margin: 0.67em 0; }
abbr[title] { border-bottom: 1px dotted; }
b, strong { font-weight: bold; }
dfn { font-style: italic; }
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }
mark { background: #ff0; color: #000; }
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }
pre { white-space: pre-wrap; }
q { quotes: "\201C" "\201D" "\2018" "\2019"; }
small { font-size: 80%; }
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }
img { border: 0; }
svg:not(:root) { overflow: hidden; }
figure { margin: 0; }
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }
legend { border: 0; padding: 0; }
button, input, select, textarea { font-family: inherit; font-size: 100%; margin: 0; }
button, input { line-height: normal; }
button, select { text-transform: none; }
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; cursor: pointer; }
button[disabled], html input[disabled] { cursor: default; }
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; padding: 0; }
input[type="search"] { -webkit-appearance: textfield; -moz-box-sizing: content-box; -webkit-box-sizing: content-box; box-sizing: content-box; }
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }
textarea { overflow: auto; vertical-align: top; }
table { border-collapse: collapse; border-spacing: 0; }
*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }
html, body { font-size: 100%; }
body { background: white; color: #222222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }
a:hover { cursor: pointer; }
a:focus { outline: none; }
img, object, embed { max-width: 100%; height: auto; }
object, embed { height: 100%; }
img { -ms-interpolation-mode: bicubic; }
#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }
.left { float: left !important; }
.right { float: right !important; }
.text-left { text-align: left !important; }
.text-right { text-align: right !important; }
.text-center { text-align: center !important; }
.text-justify { text-align: justify !important; }
.hide { display: none; }
.antialiased, body { -webkit-font-smoothing: antialiased; }
img { display: inline-block; vertical-align: middle; }
textarea { height: auto; min-height: 50px; }
select { width: 100%; }
p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }
.subheader, #content #toctitle, .admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title, .tableblock > caption { line-height: 1.4; color: #7a2518; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }
a { color: #005498; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #00467f; }
a img { border: none; }
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: Georgia, "URW Bookman L", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; color: #ba3925; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #e99b8f; line-height: 0; }
h1 { font-size: 2.125em; }
h2 { font-size: 1.6875em; }
h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }
h4 { font-size: 1.125em; }
h5 { font-size: 1.125em; }
h6 { font-size: 1em; }
hr { border: solid #dddddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }
em, i { font-style: italic; line-height: inherit; }
strong, b { font-weight: bold; line-height: inherit; }
small { font-size: 60%; line-height: inherit; }
code { font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; color: #6d180b; }
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }
ul, ol { margin-left: 1.5em; }
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }
abbr, acronym { text-transform: uppercase; font-size: 90%; color: #222222; border-bottom: 1px dotted #dddddd; cursor: help; }
abbr { text-transform: none; }
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: inherit; color: #555555; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #555555; }
blockquote, blockquote p { line-height: 1.6; color: #6f6f6f; }
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }
.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }
@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
.print-only { display: none !important; }
@media print { * { background: transparent !important; color: #000 !important; box-shadow: none !important; text-shadow: none !important; }
  a, a:visited { text-decoration: underline; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
  thead { display: table-header-group; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page { margin: 0.5cm; }
  p, h2, h3, #toctitle, .sidebarblock > .content > .title { orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }
table { background: white; margin-bottom: 1.25em; border: solid 1px #dddddd; }
table thead, table tfoot { background: whitesmoke; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #222222; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #222222; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f9f9f9; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }
.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }
*:not(pre) > code { font-size: 0.9375em; padding: 1px 3px 0; white-space: nowrap; background-color: #f2f2f2; border: 1px solid #cccccc; -webkit-border-radius: 4px; border-radius: 4px; text-shadow: none; }
pre, pre > code { line-height: 1.4; color: inherit; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }
kbd.keyseq { color: #555555; }
kbd:not(.keyseq) { display: inline-block; color: #222222; font-size: 0.75em; line-height: 1.4; background-color: #F7F7F7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; margin: -0.15em 0.15em 0 0.15em; padding: 0.2em 0.6em 0.2em 0.5em; vertical-align: middle; white-space: nowrap; }
kbd kbd:first-child { margin-left: 0; }
kbd kbd:last-child { margin-right: 0; }
.menuseq, .menu { color: #090909; }
p a > code:hover { color: #561309; }
#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }
#header { margin-bottom: 2.5em; }
#header > h1 { color: black; font-weight: normal; border-bottom: 1px solid #dddddd; margin-bottom: -28px; padding-bottom: 32px; }
#header span { color: #6f6f6f; }
#header #revnumber { text-transform: capitalize; }
#header br { display: none; }
#header br + span { padding-left: 3px; }
#header br + span:before { content: "\2013 \0020"; }
#header br + span.author { padding-left: 0; }
#header br + span.author:before { content: ", "; }
#toc { border-bottom: 3px double #ebebeb; padding-bottom: 1.25em; }
#toc > ul { margin-left: 0.25em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
#toc ul { list-style-type: none; }
#toctitle { color: #7a2518; }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; }
  #toc.toc2 { position: fixed; width: 20em; left: 0; top: 0; border-right: 1px solid #ebebeb; border-bottom: 0; z-index: 1000; padding: 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; }
  #toc.toc2 > ul { font-size: .95em; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1.25em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; }
  body.toc2.toc-right #toc.toc2 { border-right: 0; border-left: 1px solid #ebebeb; left: auto; right: 0; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; border-width: 0; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }
#content #toc a { text-decoration: none; }
#content #toctitle { font-weight: bold; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-size: 1em; padding-left: 0.125em; }
#footer { max-width: 100%; background-color: #222222; padding: 1.25em; }
#footer-text { color: #dddddd; line-height: 1.44; }
.sect1 { padding-bottom: 1.25em; }
.sect1 + .sect1 { border-top: 3px double #ebebeb; }
#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; width: 1em; margin-left: -1em; display: block; text-decoration: none; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: '\00A7'; font-size: .85em; vertical-align: text-top; display: block; margin-top: 0.05em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #ba3925; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #a53221; }
.imageblock, .literalblock, .listingblock, .verseblock, .videoblock { margin-bottom: 1.25em; }
.admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-align: left; font-weight: bold; }
.tableblock > caption { text-align: left; font-weight: bold; white-space: nowrap; overflow: visible; max-width: 0; }
table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }
.admonitionblock > table { border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #dddddd; color: #6f6f6f; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }
.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6, .exampleblock > .content p { color: #333333; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6 { line-height: 1; margin-bottom: 0.625em; }
.exampleblock > .content h1.subheader, .exampleblock > .content h2.subheader, .exampleblock > .content h3.subheader, .exampleblock > .content .subheader#toctitle, .sidebarblock.exampleblock > .content > .subheader.title, .exampleblock > .content h4.subheader, .exampleblock > .content h5.subheader, .exampleblock > .content h6.subheader { line-height: 1.4; }
.exampleblock.result > .content { -webkit-box-shadow: 0 1px 8px #d9d9d9; box-shadow: 0 1px 8px #d9d9d9; }
.sidebarblock { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6, .sidebarblock p { color: #333333; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6 { line-height: 1; margin-bottom: 0.625em; }
.sidebarblock h1.subheader, .sidebarblock h2.subheader, .sidebarblock h3.subheader, .sidebarblock .subheader#toctitle, .sidebarblock > .content > .subheader.title, .sidebarblock h4.subheader, .sidebarblock h5.subheader, .sidebarblock h6.subheader { line-height: 1.4; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; line-height: 1.6; }
.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }
.literalblock > .content pre, .listingblock > .content pre { background: none; border-width: 1px 0; border-style: dotted; border-color: #bfbfbf; -webkit-border-radius: 4px; border-radius: 4px; padding: 0.75em 0.75em 0.5em 0.75em; word-wrap: break-word; }
.literalblock > .content pre.nowrap, .listingblock > .content pre.nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
.literalblock > .content pre > code, .listingblock > .content pre > code { display: block; }
@media only screen { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.8em; } }
@media only screen and (min-width: 768px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.9em; } }
@media only screen and (min-width: 1280px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 1em; } }
.listingblock > .content { position: relative; }
.listingblock:hover code[class*=" language-"]:before { text-transform: uppercase; font-size: 0.9em; color: #999; position: absolute; top: 0.375em; right: 0.375em; }
.listingblock:hover code.asciidoc:before { content: "asciidoc"; }
.listingblock:hover code.clojure:before { content: "clojure"; }
.listingblock:hover code.css:before { content: "css"; }
.listingblock:hover code.groovy:before { content: "groovy"; }
.listingblock:hover code.html:before { content: "html"; }
.listingblock:hover code.java:before { content: "java"; }
.listingblock:hover code.javascript:before { content: "javascript"; }
.listingblock:hover code.python:before { content: "python"; }
.listingblock:hover code.ruby:before { content: "ruby"; }
.listingblock:hover code.scss:before { content: "scss"; }
.listingblock:hover code.xml:before { content: "xml"; }
.listingblock:hover code.yaml:before { content: "yaml"; }
.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }
.listingblock.terminal pre .command:not([data-prompt]):before { content: '$'; }
table.pyhltable { border: 0; margin-bottom: 0; }
table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; }
table.pyhltable td.code { padding-left: .75em; padding-right: 0; }
.highlight.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #dddddd; }
.highlight.pygments .lineno { display: inline-block; margin-right: .25em; }
table.pyhltable .linenodiv { background-color: transparent !important; padding-right: 0 !important; }
.quoteblock { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
.quoteblock blockquote { margin: 0 0 1.25em 0; padding: 0 0 0.5625em 0; border: 0; }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: -.25em; padding-bottom: 0.5625em; font-size: inherit; color: #555555; }
.quoteblock .attribution br { display: none; }
.quoteblock .attribution cite { display: block; margin-bottom: 0.625em; }
table thead th, table tfoot th { font-weight: bold; }
table.tableblock.grid-all { border-collapse: separate; border-spacing: 1px; -webkit-border-radius: 4px; border-radius: 4px; border-top: 1px solid #dddddd; border-bottom: 1px solid #dddddd; }
table.tableblock.frame-topbot, table.tableblock.frame-none { border-left: 0; border-right: 0; }
table.tableblock.frame-sides, table.tableblock.frame-none { border-top: 0; border-bottom: 0; }
table.tableblock td .paragraph:last-child p, table.tableblock td > p:last-child { margin-bottom: 0; }
th.tableblock.halign-left, td.tableblock.halign-left { text-align: left; }
th.tableblock.halign-right, td.tableblock.halign-right { text-align: right; }
th.tableblock.halign-center, td.tableblock.halign-center { text-align: center; }
th.tableblock.valign-top, td.tableblock.valign-top { vertical-align: top; }
th.tableblock.valign-bottom, td.tableblock.valign-bottom { vertical-align: bottom; }
th.tableblock.valign-middle, td.tableblock.valign-middle { vertical-align: middle; }
p.tableblock.header { color: #222222; font-weight: bold; }
td > div.verse { white-space: pre; }
ol { margin-left: 1.75em; }
ul li ol { margin-left: 1.5em; }
dl dd { margin-left: 1.125em; }
dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }
ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }
ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }
ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }
ul.checklist li > p:first-child > i[class^="icon-check"]:first-child, ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }
ul.checklist li > p:first-child > input[type="checkbox"]:first-child { position: relative; top: 1px; }
ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }
.unstyled dl dt { font-weight: normal; font-style: normal; }
ol.arabic { list-style-type: decimal; }
ol.decimal { list-style-type: decimal-leading-zero; }
ol.loweralpha { list-style-type: lower-alpha; }
ol.upperalpha { list-style-type: upper-alpha; }
ol.lowerroman { list-style-type: lower-roman; }
ol.upperroman { list-style-type: upper-roman; }
ol.lowergreek { list-style-type: lower-greek; }
.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }
td.hdlist1 { padding-right: .8em; font-weight: bold; }
td.hdlist1, td.hdlist2 { vertical-align: top; }
.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }
.colist > table tr > td:first-of-type { padding: 0 .8em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }
.qanda > ol > li > p > em:only-child { color: #00467f; }
.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }
.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }
.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }
a.image { text-decoration: none; }
span.footnote, span.footnoteref { vertical-align: super; font-size: 0.875em; }
span.footnote a, span.footnoteref a { text-decoration: none; }
#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -.25em 0 .75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em; line-height: 1.3; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.2em; margin-bottom: .2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }
.gist .file-data > table { border: none; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }
div.unbreakable { page-break-inside: avoid; }
.big { font-size: larger; }
.small { font-size: smaller; }
.underline { text-decoration: underline; }
.overline { text-decoration: overline; }
.line-through { text-decoration: line-through; }
.aqua { color: #00bfbf; }
.aqua-background { background-color: #00fafa; }
.black { color: black; }
.black-background { background-color: black; }
.blue { color: #0000bf; }
.blue-background { background-color: #0000fa; }
.fuchsia { color: #bf00bf; }
.fuchsia-background { background-color: #fa00fa; }
.gray { color: #606060; }
.gray-background { background-color: #7d7d7d; }
.green { color: #006000; }
.green-background { background-color: #007d00; }
.lime { color: #00bf00; }
.lime-background { background-color: #00fa00; }
.maroon { color: #600000; }
.maroon-background { background-color: #7d0000; }
.navy { color: #000060; }
.navy-background { background-color: #00007d; }
.olive { color: #606000; }
.olive-background { background-color: #7d7d00; }
.purple { color: #600060; }
.purple-background { background-color: #7d007d; }
.red { color: #bf0000; }
.red-background { background-color: #fa0000; }
.silver { color: #909090; }
.silver-background { background-color: #bcbcbc; }
.teal { color: #006060; }
.teal-background { background-color: #007d7d; }
.white { color: #bfbfbf; }
.white-background { background-color: #fafafa; }
.yellow { color: #bfbf00; }
.yellow-background { background-color: #fafa00; }
span.icon > [class^="icon-"], span.icon > [class*=" icon-"] { cursor: default; }
.admonitionblock td.icon [class^="icon-"]:before { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #005498; color: #003f72; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }
.conum { display: inline-block; color: white !important; background-color: #222222; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; width: 20px; height: 20px; font-size: 12px; font-weight: bold; line-height: 20px; font-family: Arial, sans-serif; font-style: normal; position: relative; top: -2px; letter-spacing: -1px; }
.conum * { color: white !important; }
.conum + b { display: none; }
.conum:after { content: attr(data-value); }
.conum:not([data-value]):empty { display: none; }
.literalblock > .content > pre, .listingblock > .content > pre { -webkit-border-radius: 0; border-radius: 0; }

</style>
</head>
<body class="book">
<div id="header">
<h1>Fermat Documentation</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="DocumentationOrganization">Documentation Organization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The system documentation is written is asciidoc format in order to be portable to many formats.<br>
We will decompose the system in the following way:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First we will describe the system functionality as a whole app, where we will describe the actors and sub-apps involved in the system.</p>
</li>
<li>
<p>The next part is divided in the description of each layer. Inside every layer section we will find a general explanation of the layer, and follow by a list of all the plug-ins living in the layer.</p>
</li>
<li>
<p>Every plug-in will have its own subdivision, where we will find one reference for every developer who is in charge of an implementation of the plug-in.</p>
</li>
<li>
<p>Then each developer will have a final subdivision of its documentation to refer separately to the different version of the plug-in implemented.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In this way we will get a central documentation where we will find a whole range of information about the system, from usage examples of the application to technical description of the plug-ins. We don&#8217;t want show code in this document, all the implementation details will be described inside the source files. Although, we will see in some cases technical discussions about the implementation challenges described in a slightly more abstract way than the source code.</p>
</div>
<div class="paragraph">
<p>So, the general structure of this document can be seen in the following way</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Platform Description</p>
<div class="ulist">
<ul>
<li>
<p>Layer Description</p>
<div class="ulist">
<ul>
<li>
<p>Plug-in Developer Index</p>
<div class="ulist">
<ul>
<li>
<p>Developer Version Index</p>
<div class="ulist">
<ul>
<li>
<p>Version Description</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<h1 id="PlatformDescription" class="sect0">Platform Description</h1>
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the following sections we will explore:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The functional description of this system (what is Fermat? how can we use it?).</p>
</li>
<li>
<p>The <a href="#PlatformDescription-Wallets">wallets</a> and <a href="#PlatformDescription-SubApps">applications</a> that run over this platform.</p>
</li>
<li>
<p>The <a href="#PlatformDescription-SourceCode">code distribution and essentials concepts</a> needed to.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="PlatformDescription-Wallets">Wallets</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_bitcoin_wallet">Bitcoin Wallet</h3>
<div class="paragraph">
<p>This wallet is represented by the Nich Wallet Bitcoin Reference Wallet.<br>
We will explore the functionality of this wallet and all the modules involved in different work cycles.<br></p>
</div>
</div>
<div class="sect2">
<h3 id="_argentina_bitcoin_wallet">Argentina Bitcoin Wallet</h3>
<div class="paragraph">
<p>to be completed</p>
</div>
</div>
<div class="sect2">
<h3 id="_bitcoin_loss_protected_wallet">Bitcoin Loss Protected Wallet</h3>
<div class="paragraph">
<p>to be completed</p>
</div>
</div>
<div class="sect2">
<h3 id="_argentina_loss_protected_wallet">Argentina Loss Protected Wallet</h3>
<div class="paragraph">
<p>to be completed</p>
</div>
</div>
<div class="sect2">
<h3 id="_argentina_discount_wallet">Argentina Discount Wallet</h3>
<div class="paragraph">
<p>to be completed</p>
</div>
</div>
<div class="sect2">
<h3 id="_rounded_wallet">Rounded Wallet</h3>
<div class="paragraph">
<p>to be completed</p>
</div>
</div>
<div class="sect2">
<h3 id="_argentina_multi_account_wallet">Argentina Multi Account Wallet</h3>
<div class="paragraph">
<p>to be completed</p>
</div>
</div>
<div class="sect2">
<h3 id="_argentina_bank_notes_wallet">Argentina Bank Notes Wallet</h3>
<div class="paragraph">
<p>to be completed</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="PlatformDescription-SubApps">Subapplications</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is important to mention that every subapp described here is divided in a user interface and a logic module. The application UI runs over the platform and the logic that control the app lives inside the platform. This means that for each subapplication we will find a plug-in in the <a href="#Fermat-DMP-ModuleLayer">module layer</a> that implements the behavior of the app.</p>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-Shell">Shell</h3>
<div class="paragraph">
<p>Brings the available functionality when no user has logged in.<br>
Some trivial functionalities are the login functionality, account creation, forgotten password, etc.<br></p>
</div>
<div class="paragraph">
<p>The login policies are pending to be discussed. One initial idea is that the login should not be done every time the user opens the Fermat app or turn on the device. However we should consider that this could be a kind of security mechanism, we could also have expiration session times.<br></p>
</div>
<div class="paragraph">
<p>Another idea is to set a limit in the amount of money the user can manage without logging in.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-WalletManager">Wallet Manager</h3>
<div class="paragraph">
<p>This app let the user administrate the different <a href="#PlatformDescription-Wallets">wallets</a> a he has installed in his device.<br>
There are some operations between wallets that may be appropriate for this module to handle, for example we could manage transactions between wallets of a same user using this app.<br></p>
</div>
<div class="paragraph">
<p>The first set of wallets will be installed by default, in the future the manager will get new wallets from the <a href="#Platform-SubApps-WalletStore">wallet store</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-WalletFactory">Wallet Factory</h3>
<div class="paragraph">
<p>This subapp is focused in developers, it lets a user edit the navigation structure of a wallet and create what we call a wallet factory project.<br>
This projects will be managed by a subapp called <a href="#Platform-SubApps-WalletPublisher">Wallet Publisher</a>.</p>
</div>
<div class="paragraph">
<p>When a user edit a wallet he can set (add) the resources (like images) the wallet use.<br>
Those resources are not saved in the wallet runtime but are referenced using the wallet resources plug-in.<br></p>
</div>
<div class="paragraph">
<p>When the wallet manager install a new wallet it ask the corresponding resources to the wallet resources plug-in.<br></p>
</div>
<div class="paragraph">
<p>At this moment the resources are stored in a github repository associated to each wallet. In the future we plan to avoid the necessity of a central point of reference to download resources and to have them distributed over the platform&#8217;s users.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-WalletPublisher">Wallet Publisher</h3>
<div class="paragraph">
<p>This subapp can read the output product of the <a href="#Platform-SubApps-WalletFactory">wallet factory</a> which are files called wallet factory projects.</p>
</div>
</div>
<div class="sect2">
<h3 id="_this_need_to_be_revised_explained">THIS NEED TO BE REVISED/EXPLAINED</h3>
<div class="paragraph">
<p>This module publish the new wallet in the wallet store.<br>
When another user installs the new wallet, this subapp will configure the wallet runtime to run the new wallet (??)</p>
</div>
<div class="paragraph">
<p>This module also let a wallet administrator (developer, marketing agency, brand, etc) interact with the wallet users and know some statistics to be defined like number of users.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-WalletStore">Wallet Store</h3>
<div class="paragraph">
<p>This subapp shows the user the different wallets he can download and install in his device.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-WalletEditor">Wallet Editor</h3>
<div class="paragraph">
<p>This subapp let an actor take any wallet in the <a href="#Platform-SubApps-WalletStore">wallet store</a> and edit it. The subapp is focused to marketing agencies.<br>
Here edition means that the subapp will take the navigation structure of the selected wallet from the wallet runtime and copy it to what we will call a wallet editor project.<br>
Basically, the edition let the actor change the navigation structure and user interface, but it doesn&#8217;t let you change the wallet business logic.</p>
</div>
<div class="paragraph">
<p>This editor let the actors change the resources settled by the <a href="#Platform-SubApps-WalletFactory">wallet factory</a> and basically make a fork of the wallet.<br></p>
</div>
<div class="paragraph">
<p>Following the life cycle, this project will be taken by a particular brand before the publishing of the wallet.</p>
</div>
</div>
<div class="sect2">
<h3 id="_wallet_licensing">Wallet Licensing</h3>

</div>
<div class="sect2">
<h3 id="Platform-SubApps-ShopManager">Shop Manager</h3>
<div class="paragraph">
<p>Similar to the <a href="#Platform-SubApps-WalletManager">wallet manager</a> this subapp let shop owners administrate their different shops in this platform.<br>
The shops are individually managed using the <a href="#Platform-SubApps-shop">shop subapp</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-Shop">Shop</h3>
<div class="paragraph">
<p>This subapp let a shop owner manage his shop. This include adding products, the store location, editing prices, emitting discounts, etc. Creating a presentation page in the platform.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-Brand">Brand</h3>
<div class="paragraph">
<p>This subapp let a brand navigate through the wallets it has published and create marketing products like coupons.<br></p>
</div>
<div class="paragraph">
<p>There will be a mechanism for the interaction between a brands and shops to associate in the use of marketing products.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-Retailer">Retailer</h3>
<div class="paragraph">
<p>TO BE COMPLETED</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-CryptoBroker">Crypto Broker</h3>
<div class="paragraph">
<p>This is a subapp focused for the use of brokers (people who buy and sell crypto currencies).<br>
The brokers are central actors in this platform.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-TopUpPoint">Top Up Point</h3>
<div class="paragraph">
<p>The idea is to let actors provide the service of selling crypto currency in exchange of fiat currency.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-CashOutPoint">Cash Out Point</h3>
<div class="paragraph">
<p>Similar to <a href="#Platform-SubApps-TopUpPoint">top up point</a>, this subapp let actors provide the service of buying crypto currency in exchange of fiat currency.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-Designer">Designer</h3>
<div class="paragraph">
<p>This subapp is initially intended to let developers contact user interface designers.</p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-Developer">Developer</h3>
<div class="paragraph">
<p>This subapp should let user contact the developers of their wallets.<br></p>
</div>
</div>
<div class="sect2">
<h3 id="Platform-SubApps-Marketer">Marketer</h3>
<div class="paragraph">
<p>TO BE COMPLETED</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="PlatformDescription-SourceCode">Source Code Distribution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fermat Platform is divided in three main subsystems.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Fermat-PIP</dt>
<dd>
<p><strong>P</strong>lug-<strong>i</strong>ns <strong>P</strong>latform. Basic components that bring essential functionality to the platform. This components are in general independent of the functionality to be implemented above the system.</p>
</dd>
<dt class="hdlist1">Fermat-P2P</dt>
<dd>
<p>Brings the network infrastructure</p>
</dd>
<dt class="hdlist1">Fermat-DMP</dt>
<dd>
<p><strong>D</strong>igital <strong>M</strong>oney <strong>P</strong>latform. This modules implement the tools for the <a href="#PlatformDescription-SubApps">subapplications</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Each of this subsystem is divided in layers. Inside the layers we can find plug-ins, each plug-in has a specific responsability. As a convention we call the plug-ins inside Fermat-PIP Addons instead of Plug-ins.<br>
Plug-ins need to identify themself in order to ask for resources to addons. This is a security and organizational decision that helps the system organization as a whole.</p>
</div>
<div class="paragraph">
<p>We can also identify outside these subsystems two main structures. One is what we call fermat-api and the other is fermat-core.</p>
</div>
<div class="sect2">
<h3 id="_fermat_api">fermat-api</h3>
<div class="paragraph">
<p>The modules inside each layer define the necessary interfaces to accomplish their duty inside the plug-ins. However, this interfaces bring many times too much information to the developer. This is why we define a group of reduces interfaces to export to other layers. This interfaces among other definitions can be found in this module called fermat-pip-api.+
Some other definitions are for example exceptions and enums.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fermat_core">fermat-core</h3>
<div class="paragraph">
<p>This set of classes are the representation of the platform. The purpose of this modules is to initialize the whole system and to monitor the way the application is behaving.<br></p>
</div>
</div>
<div class="sect2">
<h3 id="_initialization_process">Initialization process</h3>
<div class="paragraph">
<p>The most intuitive way to initialize the platform is by creating an instance of each layer and then of each plug-in inside.+
So the sequence could be:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Platform -&gt; Layer -&gt; Plug-in</pre>
</div>
</div>
<div class="paragraph">
<p>One problem with this approach is that if we develop a new version of a plug-in tha needs more resources than the previous one, then there may be some devices that won&#8217;t be able to run the new version and would opt for the previous one.<br>
We would like that the platform could decide which version instantiate without the user having to indicate explicitly.<br>
This is why we defined a class named DeveloperBitDubai. The responsibility of this layer is to decide which version of a plug-in the platform should instantiate. Others developers will have there own Developer class to accomplish the same function.</p>
</div>
<div class="paragraph">
<p>The new initialization sequence would be:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Platform -&gt; Layer -&gt; Developer -&gt; Plug-in</pre>
</div>
</div>
<div class="paragraph">
<p>This works fine as long as we stay as the only developer for a plug-in. We could imagine that in the future a new developer would like to create it&#8217;s own version of an existing plug-in to offer to the platform.<br>
In this scenario we find again the problem we had for versions. Who decides which developer implementation we should select.
We created the PluginSubsystem class to solve this problem. The subsystem class instantiate the developer class and finally this developer class instantiate the version of the plug-in.</p>
</div>
<div class="paragraph">
<p>The final initialization sequence is therefore:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Platform -&gt; Layer -&gt; Subsysyem -&gt; Developer -&gt; Plug-in</pre>
</div>
</div>
<div class="sect3">
<h4 id="__end_of_fermat_documentations_platfomr_platformdescription_asciidoc">(END OF /fermat-documentations/platfomr/platformDescription.asciidoc)</h4>

</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fermat_pip_system_layers">Fermat-PIP System Layers</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_definitions_layer">Definitions Layer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>At the moment this layer provides definitions to the others layers like the list of all the crypto currencies supported by the platform, list of plug-ins, list of addons, etc.<br>
It also provides some standard implementations of common pieces of code like asymmetric encryption methods and currency conversion calculation methods.<br></p>
</div>
<div class="paragraph">
<p>Some folders and their description:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">crypto/asymmetric</dt>
<dd>
<p>Package that provide asymmetric encryption methods using eliptic curve cryptography.</p>
</dd>
<dt class="hdlist1">crypto/util</dt>
<dd>
<p>related classes for the asymmetric package implementation.</p>
</dd>
<dt class="hdlist1">developer</dt>
<dd>
<p>(<strong>draft of a</strong>) Class related to manage the information of a developer, like email, name and other information.</p>
</dd>
<dt class="hdlist1">event</dt>
<dd>
<p>We can also find the definition of the EventMonitor, PlatformEvent and DeasWithEventMonitor interfaces.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This classes may be relocated to the platform service layer.<br>
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1">diagrams/wallets</dt>
<dd>
<p><strong>classes with not quite clear purpose</strong></p>
</dd>
<dt class="hdlist1">enums</dt>
<dd>
<p>Enums that represent different lists like plug-ins, addons, crypto currencies, fiat currencies, etc.</p>
</dd>
<dt class="hdlist1">Money</dt>
<dd>
<p><strong>Containers classes (classes with setter and getters) for different data. Not entirely well implemented (for example, they use double to represent currency amounts instead of long)</strong></p>
</dd>
<dt class="hdlist1">util</dt>
<dd>
<p>Simple methods that may appear along the platform and should be implemented in a standard way like money conversion calculations.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_os_layer">OS Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_template_subtitle">Template Subtitle</h3>
<div class="paragraph">
<p>This is a template file</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer">Plug-ins in this layer</h3>

</div>
<div class="sect2">
<h3 id="_database_system">Database System</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_device_location">Device Location</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_2">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_2">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_2">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_file_system">File System</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_3">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_3">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_3">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_platform_service_layer">Platform Service Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_template_subtitle_2">Template Subtitle</h3>
<div class="paragraph">
<p>This is a template file</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer_2">Plug-ins in this layer</h3>

</div>
<div class="sect2">
<h3 id="_location_subsystem">Location Subsystem</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_4">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_4">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_4">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_error_manager">Error MAnager</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_5">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_5">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_5">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_event_manager">Event Manager</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_6">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_6">Version 1</h5>
<div class="sect5">
<h6 id="_plug_in_description">Plug-in Description</h6>
<div class="paragraph">
<p>Along the system many modules use events to communicate specific information of the state of the platform. For example, there is an event to communicate a variation in the exchange rate of a crypto currency, another event informs when a user logs in, etc.<br>
For each event we can define a corresponding component called <strong>event listeners</strong> which will be informed every time the event occurs.
The event manager is the plug-in responsable of receiving the events thrown by the system and inform them to the event listeners.</p>
</div>
<div class="paragraph">
<p>An event listeners have a reference to a module called <strong>event handlers</strong> which is the component invoked to react when an event occur.<br>
The event handler try to execute an action when he is invoke by the listener. This action can possibly fail and throw an exception (java exception). However, as we said before, events have an informative role so it is not correct for the system to throw an exception to the event listener who invoked the handler neither to the module that threw the event.<br>
To solve this problem, the event listener catch the exception and gives it to a component called <strong>event monitor</strong> which register the exceptions and inform the platform.<br>
We expect that in the future the platform will be able to make decisions according to the information provided by the event monitor.s</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hardware_layer">Hardware Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_template_subtitle_3">Template Subtitle</h3>
<div class="paragraph">
<p>This is a template file</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer_3">Plug-ins in this layer</h3>

</div>
<div class="sect2">
<h3 id="_local_device">Local Device</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_7">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_7">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_6">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_layer">User Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_template_subtitle_4">Template Subtitle</h3>
<div class="paragraph">
<p>This is a template file</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer_4">Plug-ins in this layer</h3>

</div>
<div class="sect2">
<h3 id="_device_user">Device User</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_8">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_8">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_7">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_extra_user">Extra User</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_9">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_9">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_8">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_intra_user">Intra User</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_10">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_10">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_9">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_license_layer">License Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_template_subtitle_5">Template Subtitle</h3>
<div class="paragraph">
<p>This is a template file</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer_5">Plug-ins in this layer</h3>

</div>
<div class="sect2">
<h3 id="_plug_in">Plug-in</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_11">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_11">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_10">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_wallet">Wallet</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_12">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_12">Version 1</h5>
<div class="sect5">
<h6 id="_first_subsection_11">First Subsection</h6>
<div class="ulist">
<div class="title">Example List</div>
<ul>
<li>
<p>This</p>
<div class="ulist">
<ul>
<li>
<p>is</p>
<div class="ulist">
<ul>
<li>
<p>a</p>
<div class="ulist">
<ul>
<li>
<p>nested</p>
<div class="ulist">
<ul>
<li>
<p>list</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fermat_p2p_system_layers">Fermat-P2P System Layers</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="Fermat-P2P-CommunicationLayer">Communication Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_layer_description">Layer Description</h3>
<div class="paragraph">
<p>At the moment of the creation of this document the communication layer is the main (and only) layer inside Fermat-P2P subsystem.<br></p>
</div>
<div class="paragraph">
<p>This layer give the communication services to the upper layers.<br>
A distinguished difference between this layer and others in Fermat system is that this is the first layer that interact with upper layers as a whole and not as plug-ins, i.e. plug-ins that need communication services ask them to the layer interface and not to the plug-ins inside.<br>
Even more, a purpose of this layer is to abstract completely the plug-ins managing the real connection The upper layers should not be aware of the technology in use (wi-fi, NFC, p2p, bluetooth, etc.) and problems related to a connection should be solved by the communication layer without disturbing the clients.<br></p>
</div>
</div>
<div class="sect2">
<h3 id="Fermat-P2P-CommunicationLayer-CloudServer-Connection-Technologies">Connection technologies</h3>
<div class="sect3">
<h4 id="_cloud">Cloud</h4>
<div class="paragraph">
<p>In this first implementation will rely in a cloud server. At initialization the devices will contact through the cloud client plug-in with the server to inform they are online and can be contacted by other users.<br></p>
</div>
<div class="paragraph">
<p>There is an identification system that identify devices, actors and <a href="#Fermat-DMP-NetworkServiceLayer">network services</a> that consist in pairs of keys generating by asymmetric cryptography methods.<br></p>
</div>
</div>
<div class="sect3">
<h4 id="_p2p">P2P</h4>
<div class="paragraph">
<p>In the future we intend to move our communication infrastructure to a peer-to-peer architecture. This will bring both many challenges and advantages. For example, if we rely in a server or group of servers attacks to the service could be focused on the server.<br></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer_6">Plug-ins in this layer</h3>
<div class="paragraph">
<p>Plug-ins in this layer essentially consist on the modules needed for the implementation of the communication protocols and interfaces for the different <a href="#Fermat-P2P-CommunicationLayer-CloudServer-Connection-Technologies">connection technologies</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cloud_client">Cloud Client</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_13">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_13">Version 1</h5>
<div class="sect5">
<h6 id="_plug_in_description_2">Plug-in Description</h6>

</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cloud_server">Cloud Server</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_14">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_14">Version 1</h5>
<div class="sect5">
<h6 id="_plug_in_description_3">Plug-in Description</h6>

</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fermat_dmp_system_layers">Fermat-DMP System Layers</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="Fermat-DMP-NetworkServiceLayer">Network Service Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_layer_description_2">Layer Description</h3>
<div class="paragraph">
<p>The plug-ins in this layer are the ones that let the functionality of the platform transcend a single device to let different users interact with each other over the platform. This layer is the main consumer of the <a href="#Fermat-P2P-CommunicationLayer">communication layer</a> services.<br></p>
</div>
<div class="paragraph">
<p>The modules in the world layer also implement interaction with entities that live outside the device, but in that layer the components we interact with live outside the platform.<br></p>
</div>
<div class="paragraph">
<p>There are some common patterns in the way all the network services (the plug-ins in this layer) act.<br>
Let&#8217;s say we have two devices A and B and a network service that is implemented in both devices. The network service implementations will communicate as pairs, i.e. the  network service implementation of A will interact directly (in a logical way) to the  implementation in B and vice versa. Physically the communication will be conducted trough the communication layer but the components will interact as if they where talking directly to each other (as if they were in the same device).<br></p>
</div>
<div class="paragraph">
<p>To implement this, each plug-in (network service) has two special classes. One represent the local network service and the other represent the remote network service.<br>
The remote network service class internally has a connection provided by communication layer. When two devices A and B interact trough a network service we have this imageMiddleware:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>       Device A           Device B
    +-------------+    +-------------+
    | +---------+ |    | +---------+ |
    | |  Local  | |    | | Remote  | |
    | | Network |========| Network | |
    | | Service | |    | | Service | |
    | +---------+ |    | +---------+ |
    |      *      |    |      *      |
    |      *      |    |      *      |
    |      *      |    |      *      |
    | +---------+ |    | +---------+ |
    | | Remote  | |    | |  Local  | |
    | | Network |========| Network | |
    | | Service | |    | | Service | |
    | +---------+ |    | +---------+ |
    +-------------+    +-------------+

 Reference:
      ====  connection
      ****  interaction</pre>
</div>
</div>
<div class="paragraph">
<p>Network services have a pair of cryptography asymmetric keys. They use this keys to identify themself and sign the messages they communicate through the network.</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer_7">Plug-ins in this layer</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_basic_wallet_layer">Basic Wallet Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_layer_description_3">Layer Description</h3>
<div class="paragraph">
<p>&#8230;</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_ins_in_this_layer_8">Plug-ins in this layer</h3>

</div>
<div class="sect2">
<h3 id="_discount_wallet">Discount Wallet</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_15">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="BasicWallet-DiscountWallet-BitDubai-V1">Version 1</h5>
<div class="sect5">
<h6 id="_plug_in_description_4">Plug-in Description</h6>
<div class="paragraph">
<p>The main purpose of this plug-in is to provide an abstraction that let
the user manipulate fiat money.<br>
The important aspect is that in reality this plug-in is managing the
value in a crypto currency. This means that the user will always see his
money in his local country currency being totally transparent to him the
crypto currency representation.</p>
</div>
</div>
<div class="sect5">
<h6 id="_main_problems_the_plug_in_deals_with">Main Problems the Plug-in deals with</h6>
<div class="paragraph">
<p>The implementation of this kind of abstraction carry many technical
problems which we will discuss in this section.<br>
We will explain the factors involved and in the next sections we will
present the way the plug-in deals with this considerations. For
simplicity from now on we will assume that our local currency are USD
(US Dollars) and the crypto currency involved is BTC (Bitcoins).</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Exchange rate fluctuation</strong><br>
When dealing with different currencies we have an exchange rate involved
that varies from day to day. This characteristic is no stranger to
crypto currencies.<br>
With this consideration in mind, suppose that the user deposits in his
Discount Wallet 100 dollars and that the Bitcoin/Dollar exchange rate is
1BTC per 100USD. This means that the wallet internally will have a value
of 1 BTC and the user will see that he has 100 USD.<br>
Now, how should we act if the next day the Bitcoin/Dollar rate is:</p>
<div class="ulist">
<ul>
<li>
<p>1 BTC per 50 USD. This would mean that the value inside the wallet is
now 50 USD (and not the 100 USD the user deposited and still assumes he
has).</p>
</li>
<li>
<p>1 BTC per 200 USD. This would mean that the value inside the wallet
is now 200 USD (and not the 100 USD the user deposited and still assumes
he has).</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Deposits with different exchange rates</strong><br>
How should we act if the user deposits money in the discount wallet in
several moments at different exchange rates?</p>
</li>
<li>
<p><strong>Extractions</strong><br>
Imagine the user deposited 100USD at a rate of 1BTC per 100USD and then
deposited another 100USD but now with a rate of 1BTC per 50USD. If the
user then wants to extract 200USD from his discount wallet, how should
we respond?</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_plug_in_s_business_logic">Plug-in&#8217;s Business Logic</h6>
<div class="paragraph">
<p>Let&#8217;s answer to the questions pointed before. For convenience we will
answer the second one first.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Deposits with different exchange rates</strong><br>
We will manage this by saving the information of the exchange rate
associated to every deposit made with two tables. The first table will
deal with the registration of the credits (we will use the word credit
as synonym of deposit). This table will have a reference to what we will
call a <strong>value chunk</strong>. A value chunk is a record that tell us (between a
few other things):</p>
<div class="ulist">
<ul>
<li>
<p>The amount of fiat currency deposited by the credit operation.</p>
</li>
<li>
<p>The equivalent in crypto currency amount at that moment (this crypto
amount is what we saved as value, the fiat amount is kept as reference
of the exchange rate).</p>
</li>
<li>
<p>The state of the value chunk, at the moment of the credit it will be
created as UNSPENT. This field can also be SPENT or FATHER (we explained
their uses later)</p>
<div class="paragraph">
<p>So, initially every credit record in the Credits table will have a value
chunk assign in the ValueChunk table.</p>
</div>
<div class="paragraph">
<p>Now lets see how we use this information to treat the other issues.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Exchange rate fluctuation</strong><br>
The idea is to show the user two amounts of money, one called <strong>balance
of the wallet</strong> and the other called <strong>available amount</strong> both measured in
fiat currency units.<br>
The <strong>balance of the wallet</strong> (or simply <strong>balance</strong>) is calculated as the
sum of fiat money the user has deposited minus the sum of what he has
spent (always in fiat currency units).<br>
The <strong>available amount</strong> will represent what the user can safely spend and
its calculation is the core of this plug-ins business logic.<br>
Lets make some more precise definitions in order to define this
amount.</p>
<div class="paragraph">
<p>As we explained before, we have records saved with the information about
every deposit made. The value chunks have the information about the
crypto currency amounts we have deposited, the amount of fiat
currency we used to get that crypto and a state field.<br>
Then, we can represent a value chunk with a tuple (<em>fa</em>,<em>ca</em>,<em>s</em>) where <em>fa</em> is the
fiat currency amount registered in the record, <em>ca</em> is the crypto
currency amount registered in the record and <em>s</em> is the current state of
the record. We are ignoring other data in the representation for the
purpose of the explanation.</p>
</div>
<div class="paragraph">
<p>Now, let (fa_1 , ca_1 , s_1), &#8230; ,(fa_n , ca_n , s_n) be all the value
chunks and let currentFiatAmount be a function that tells us the
equivalent fiat amount of money represented by the crypto amount we give
it as parameter.<br>
If the current rate is 1BTC per 100USD then
currentFiatAount(1) is equal to 100. You can see that at the moment of
the creation of a value chunk (<em>fa</em>,<em>ca</em>) it holds that
currentFiatAmount(<em>ca</em>) = <em>fa</em>.</p>
</div>
<div class="paragraph">
<p>So, with this definitions made we can define with precision the balance
and available amount as follow:<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p>balance is the sum of all the fa_i that correspond to the value
chunks with state UNSPENT.</p>
</li>
<li>
<p>available amount will be the <strong>minimum between</strong> balance and the sum of
currentFiatAmount(ca_i) for the unspent chunks created with an exchange
rate below the current one, i.e. the values chunks where it holds that
currentFiatAmount(ca_i) &gt;= fa_1 and also s = UNSPENT.<br>
<strong>The user will never see an available amount superior to the balance he
has</strong> (this is a convention we took in this wallet, this could change in
other kind of wallets).</p>
<div class="paragraph">
<p>Let&#8217;s see this with some examples:<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Example 1:</strong><br>
Suppose you deposited 100USD in your Discount Wallet and that the
exchange rate at that moment was 1BTC per 100USD. In this situation you
will see that balance = available amount = 100USD and as a user you
won&#8217;t see you have really 1BTC.<br>
There will be one record in the Credits table and a value chunk
(100USD,1BTC,UNSPENT) in the ValueChunk table.<br>
Now imagine that the
exchange rate change to 1BTC per 50USD. Under this new situation you
will see balance = 100USD and an available amount of 0USD, because there
is only one ValueChunk and 50 = currentFiatAmount(1) &lt; 100.<br>
 Finally imagine that the new exchange rate is 1BTC per 200USD, Under
this situation you will see again that balance = available amount =
100USD.</p>
</li>
<li>
<p><strong>Example 2:</strong><br>
 Suppose you make two separate credits of 100USD at a rate of 1BTC per
200USD.<br>
 We will see balance = available amount = 200USD. Also two records in
the Credits record and two value chunks like (100USD,0.5BTC,UNSPENT).<br>
 Now imagine the rate drops to 1BTC per 50USD. In this situation balance = 200USD and the available amount is 0USD.<br>
 At this point, suppose we deposit another 100USD, this will add a
record to the Credits table an the value chunk (100USD, 2BTC,UNSPENT) to
the ValueChunks table. The refresh balance would be 300USD and the
available amount would be just 100USD.<br>
 Finally imagine that the rate raise up to 1BTC per 100USD. The only
chunk with currentFiatAmount(ca) &gt;= fa is the last chunk we added. So
the balance is still 300 and the available amount would be
currentFiatAmount(2) which in this case is 200USD.<br></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Extractions</strong><br>
So, our last issue deals with the way we will manage the information we
have in respect to the debits of this wallet (we will use debit as a
synonym of extraction).<br>
If the user wants to spend a fiat amount of money, say N, we check two conditions. First we check if N &gt;= 0 and then if available amount &gt;= N.<br>
If this conditions hold we add a record to a Debits table similar to the
one described for Credits table.<br>
Now, as we have saved crypto currency as value and the user wants to
spend fiat currency the big questions are:<br></p>
<div class="olist arabic">
<ol class="arabic" start="1">
<li>
<p>how much do we subtract to the available amount and to the balance?<br>
Remember that the exchange rate of the currencies changes with time and
some chunks where created at a lower rate than the actual.<br>
This means that we bought the crypto currency at a value and now this crypto amount
represent more fiat money that what we paid initially.<br>
For example, if you deposited 100USD at a rate of 1BTC per 100USD and
the exchange raise to 1BTC per 200USD you will see a balance and
available amount of 100USD, but the value inside the wallet is 1BTC
which is at the moment equivalent to 200USD.<br>
Under the logic of this wallet if you try to spend 100USD you will be
notified at the moment of paying that you have a discount of 50USD in
this case.<br>
This discount is possible because you can pay the purchase using 0.5BTC (equivalent to 100USD now but obtained at a price of 50USD). Then, the discount will be
getCurrentFiatAmout(0.5) - oldFiatValue(0.5), where oldFiatValue tells
you the equivalent amount of fiat currency that its parameter represent
using the exchange rate of the value chunk (this may be a different rate
than the actual rate as happens in this example).
We would keep a value of 0.5BTC which still represent the remaining original 50USD. The user don&#8217;t need to know this internal mechanism but can benefit from it.<br>
<strong>NOTE:</strong> One good question is, why the user does not get a discount of
100USD instead of 50USD? This will be answered in the next paragraphs.<br></p>
</li>
<li>
<p>The second question is how do we manage the value chunks to keep the
integrity of the ValueChunks, Debits and Credits tables and be able to
apply this strategy of discounts?<br>
In the example explained before the value chunk stored of (100USD,
1BTC, UNSPENT) must be changed. We will do this by changing it state to
FATHER and therefore keep in the ValueChunks table the record (100USD,
1BTC, FATHER) representing that it was partially spent and we will also
add two new (children) records. One of the children will be (50USD,
0.5BTC, SPENT) representing the fraction of the original chunk used to
pay the debit. For the other chunk we have two options:</p>
<div class="ulist">
<ul>
<li>
<p>One is to store (50,0.5,UNSPENT) representing the money kept. In this
case, note that the chunk fiat amount is equivalent to the crypto amount
calculated at the <strong>original father value chunk rate</strong> and not the actual
rate. This would be intuitively thought as if we have just extracted the
100USD needed to pay (using 0.5BTC underneath) and kept the rest without
touching it.<br></p>
</li>
<li>
<p>As an alternative, we could store as second child value chunk
(100,0.5,UNSPENT), i.e. calculating the fiat amount at the <strong>actual
exchange rate</strong> instead of the father&#8217;s original rate. We can think this
intuitively as if we have extracted the 200USD of value we had, then
paid the 100USD needed and then deposited back the remaining 100USD at
the actual exchange rate.</p>
<div class="paragraph">
<p>The difference of this two strategies is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the second strategy, you will have an apparent higher discount
(because you will have 100USD to add to the balance instead of just
50USD coming from the UNSPENT child chunk), you will also see an
available amount of 100USD instead of 50USD.<br>
The disadvantage is that if the exchange rate goes down, say to 1BTC per
150USD, the value chunk will not be available until the rate go back to
1BTC per 200USD or higher.</p>
</li>
<li>
<p>In the first approach (the one we followed in this implementation)
the value chunk will be available for the case of the rate going down to
1BTC per 150USD. So you still can have a discount in the future with the
chunk. The main advantage is that at this rate you will have this chunk
available for a debit.<br>
The disadvantage is that the discount will probably be lower and the
lower balance of the wallet will restrict the available amount to spend.</p>
<div class="paragraph">
<p>Our conclusion is that real day to day use should provide the
information to decide which approach is the best. For now, we will take
the one described first.</p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>So, let&#8217;s try to formalize the algorithm to implement this logic. We need
to calculate the discount and to modify the ValueChunks table to reflect
the debit in the way explained answering the question 2.</p>
</div>
<div class="paragraph">
<p>Lets begin as usual with some definitions used in the algorithm:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>amount to spend: N<br></p>
</li>
<li>
<p>actual value chunk being analysed: vc, we will use the notation that
vc is the tuple (fa,ca,state) where:</p>
<div class="ulist">
<ul>
<li>
<p>fa is the fiat amount of the value chunk<br></p>
</li>
<li>
<p>ca is the crypto amount of the value chunk<br></p>
</li>
<li>
<p>state is the state of the value chunk<br></p>
</li>
</ul>
</div>
</li>
<li>
<p>The discount acumulated: discount (initialy set to 0)</p>
</li>
<li>
<p>getCurrentFiatAmount: a function that given a crypto amount of
currency it returns the equivalent fiat amount at <strong>the current</strong> exchange
rate.</p>
</li>
<li>
<p>getCurrentCryptoAmount: a function that given a fiat amount of
currency it returns the equivalent crypto amount at <strong>the current</strong>
exchange rate.</p>
</li>
<li>
<p>oldFiatValue: a funtion that given a crypto amount of currency, it
returns the equivalent fiat amount calculated at the <strong>original father
chunk exchange rate</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Now we can write the algorithm</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Check that N &gt;= 0, if not we end the execution with an error message</p>
</li>
<li>
<p>Check that the available amount &gt;= N, if not end the execution with
an error message</p>
</li>
<li>
<p>Take the chunks from the ValueChunks table with state UNSPENT and
store them in a list.</p>
</li>
<li>
<p>Sort the chunks of the list putting the chunks generated at lower
exchange rate at the beginning of the list. The exchange rate of a chunk
(fa,ca,state) is equal to the quotient fa/ca.</p>
</li>
<li>
<p>Now iterate over this sorted list until you N is 0 (this condition
will eventually hold because of the steps 1 and 2). Inside this loop
proceed as follow:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre>         if(N &gt;= getCurrentFiatAmount(ca))
             N = N - getCurrentFiatAmount(ca)
             discount = discount + (getCurrentFiatAmount(ca) - fa)
             vc = (fa,ca,SPENT) // vc state is updated to SPENT
         else
             let
                  ca1 = getCurrentCryptoAmount(N)
                  ca2 = ca - ca1
                  fa1 = oldFiatValue(ca1) // the amount represented by ca1
                                          // calculated at the original father's rate
                  fa2 = oldFiatValue(ca2) // the amount represented by ca2
                                          // calculated at the original father's rate
             in
                  vc = (fa,ca,FATHER) // vc state is updated to PARENT

                  // We add two new value chunks vc1 and vc2
                  // to the ValueChunks table (the children of vc)
                  vc1 = (fa1 , ca1 , SPENT)
                  vc2 = (fa2 , ca2 , UNSPENT)
                  discount = discount + (getCurrentFiatAmount(ca1) - oldFiatValue(ca1))
                  N = 0
             end // end of let
         end // end of if-else</pre>
</div>
</div>
<div class="paragraph">
<p>Here we finished the explanation behind the business logic of this
module. The rest of this document talks about the source code structure
and implementation issues. During this explanation we have simplified
some details to make the ideas clearer. Some of this details that we
should remark are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The crypto currency can be different from Bitcoin, but a single wallet
will work with only one type of crypto currency from the beginning of it
existence to the end.</p>
</li>
<li>
<p>The same observation holds for fiat currency. A wallet can use other
currencies different than the US dollar but it will manage only one kind
of fiat currency.</p>
</li>
<li>
<p>The fiat and crypto currency amounts are represented in long integers
to avoid trouble with the precision of floating point representation.
For example, 1 USD is stored as 1000 thousandths of a dollar, and 1BTC
is stored as 100.000.000 units called satoshis. In this way we avoid
dealing with decimals in many (but unfortunately not all) calculations.</p>
</li>
<li>
<p>The tables described (Credits, Debits and ValueChunks tables) have a
few more data than mentioned.</p>
</li>
<li>
<p>The functions presented for conversions between fiat and crypto
currencies have more parameters than explained and slightly different
names too.</p>
</li>
<li>
<p>In the actual implementation the conversions will probably bring
decimals to the currencies representations. This must be treated with
care. So we will see in the actual code conversion functions that round
decimals up and down applied depending on the convenience of the
situation. The next section will explain those decisions and some
improvement to the implementation of this algorithm. The rule of thumb
to follow in this module is: No matter what is the problem, <strong>always keep
a consistent relation between the balance, available amount and internal
information stored in the wallet</strong>.<br>
For more information about the conversions functions see their
documentation in the Definitions Layer</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_implementation_notes">Implementation Notes</h6>
<div class="paragraph">
<p>In this section we try to explain how we can refine the specification
given on the previous section and treat some of its problems.<br>
The main problem to notice is that in the case of a debit, we will have
to update the ValueChunks table. If we consume an entire value chunk it
does not bring any apparent problem (we just need to mark the chunk as
SPENT). But, there is a possibility that we may need to spend only part
of a chunk and that will bring the creation of two new value chunks. The
problem with this is that in our implementation for a chunk (fa,ca,s) we
have fa and ca (the fiat amount and crypto amount of the chunk
respectively) represented as long integers, but despite the conversion
functions (getCurrentFiatAmount, oldFiatValue, etc.) will give us a long
integer, that integer will be an approximation of the real value (i.e.
the long will possibly lose the decimals of the real result of the
conversion).</p>
</div>
<div class="paragraph">
<p>This means that we will probably need to deal on how to manage those
decimal "lost". Lets attack this problem.</p>
</div>
<div class="paragraph">
<p>In the implementation we have as a parameter the crypto amount that is
the equivalent to N, lets call it cryptoToPay. A good idea would be to
reduce (or eliminate) the application of this error problematic methods,
lets see if we can use cryptoToPay to achieve this goal.</p>
</div>
<div class="paragraph">
<p>In the first branch of the if statement we have three uses of
getCurrentFiatAmount.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>         if(N &gt;= getCurrentFiatAmount(ca))
             N = N - getCurrentFiatAmount(ca)
             discount = discount + (getCurrentFiatAmount(ca) - fa)
             vc = (fa,ca,SPENT) // vc state is updated to SPENT</pre>
</div>
</div>
<div class="paragraph">
<p>We need a long integer in the three appearances of the function. First,
We can replace the if condition N &gt;= getCurrentFiatAmount(ca) with the
precise one cryptoToPay &gt;= ca.</p>
</div>
<div class="paragraph">
<p>Now we could round down the other two numbers. This would imply that we
will tell the user that the discount was lower than what it really was,
although this does not harm the integrity of the information stored it
is not the best solution and also bring other issues like problems with
the else branch of this if statement.<br>
So, the better solution is to not only stop accumulating the discount,
but also avoid subtracting to N an inaccurate amount (now the if
condition is based on cryptoToPay, so we don&#8217;t need to modify N any
more). We will instead just add up the fiat amounts of the chunks used
to pay and simply calculate the discount as N - spent, where spent
represent the result of the said sum. With this modifications and adding
the line cryptoToPay = cryptoToPay - ca, the implementation version of
this branch will be</p>
</div>
<div class="listingblock">
<div class="content">
<pre>         if(cryptoToPay &gt;= ca)
             cryptoToPay = cryptoToPay - ca
             spent = spent + fa
             vc = (fa,ca,SPENT) // vc state is updated to SPENT</pre>
</div>
</div>
<div class="paragraph">
<p>In the else branch of the if statement we will need more care.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>         else
             let
                  ca1 = getCurrentCryptoAmount(N)
                  ca2 = ca - ca1
                  fa1 = oldFiatValue(ca1)
                  fa2 = oldFiatValue(ca2)
             in
                  vc = (fa,ca,FATHER) // vc state is updated to PARENT
                  // We add two new value chunks vc1 and vc2
                  // to the ValueChunks table (the children of vc)
                  vc1 = (fa1 , ca1 , SPENT)
                  vc2 = (fa2 , ca2 , UNSPENT)
                  discount = discount + (getCurrentFiatAmount(ca1) - oldFiatValue(ca1))
                  N = 0
             end // end of let</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>We can avoid using getCurrentCryptoAmount to calculate ca1 and simply
write ca1 = cryptoToPay.<br></p>
</li>
<li>
<p>The discount line can be deleted as mentioned before.<br></p>
</li>
<li>
<p>fa2 can be calculated as fa2 = fa - fa1.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So now we only have only one tricky method application instead of the
original 8. How should we deal with this one? If we round down the user
will see a higher discount and we will alter a little bit the exchange
rate of vc2. The opposite will happen if we round up the result of
oldFiatValue(ca1). In both cases the balance of the wallet will stay
consistent, so we choose to simply round down the number.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This approach "simulates" that we have "created
money", and is important to think about this. The "real money" is what
has value, and the value in this wallet is the crypto currency (which we
haven&#8217;t rounded, not even once). This extra amount of fiat money added
to the balance won&#8217;t bring any problem because it won&#8217;t be available to
spend until exchange rate increase proportionally in order to pay for
the increased amount, i.e. if we call the increased amount produced by
the rounding increasedAmount we have that the second child chunk vc2
ends up being (oldFiatValue(ca2) + increasedAmount , ca2 , UNSEPENT),
and to be considered as part of the available amount the exchange rate
needs to go up in order to satisfy getCurrentFiatAmount(ca2) &gt;=
oldFiatValue(ca2) + increasedAmount, so the increasedAmount will be
covered by real value.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The final approach of the implementation will then be (steps 1 and 2 can
still use N):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Check that N &gt;= 0, if not we end the execution with an error message</p>
</li>
<li>
<p>Check that the available amount &gt;= N, if not end the execution with an error message</p>
</li>
<li>
<p>Take the chunks from the ValueChunks table with state UNSPENT and store them in a list.</p>
</li>
<li>
<p>Sort the chunks of the list putting the chunks generated at lower exchange rate at the beginning of the list. The exchange rate of a chunk (fa,ca,state) is equal to the quotient fa/ca.</p>
</li>
<li>
<p>Now iterate over this sorted list until you cryptoToPay is 0 (this condition will eventually hold because of the steps 1 and 2). Inside this loop proceed as follow:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre>         if(cryptoToPay &gt;= ca)
             cryptoToPay = cryptoToPay - ca
             spent = spent + fa
             vc = (fa,ca,SPENT) // vc state is updated to SPENT
         else
             let
                  ca1 = cryptoToPay
                  ca2 = ca - ca1
                  fa1 = oldFiatValueRoundedDown(ca1)
                  fa2 = fa - fa1
             in
                  vc = (fa,ca,FATHER) // vc state is updated to PARENT
                  // We add two new value chunks vc1 and vc2
                  // to the ValueChunks table (the children of vc)
                  vc1 = (fa1 , ca1 , SPENT)
                  vc2 = (fa2 , ca2 , UNSPENT)
                  cryptoToPay = 0
                  spent = spent + fa1
             end // end of let</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic" start="6">
<li>
<p>Outside the loop, calculate the discount as</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre>            discount = N - spent</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_possible_improvements_and_other_considerations">Possible improvements and other considerations</h6>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Notice that the only chunk that could be partially spent is the last
chunk used to pay the credit, i.e. the one where</p>
<div class="paragraph">
<p>N &lt; getCurrentFiatAmount(ca) or more precisely cryptoToPay &lt; ca</p>
</div>
<div class="paragraph">
<p>So, we would like to avoid or at least minimize the occurrence of this
situation. Under this idea, a good strategy would be that given a
deposit of an amount fa of fiat currency and its corresponding amount ca
of crypto currency, instead of storing one value chunk (fa,ca,UNSPENT)
we can add k chunks of the form (fa/k,ca/k,UNSPENT) where k = gcd(ca,fa)
(greatest common divisor of ca and fa).</p>
</div>
</li>
<li>
<p>The last idea will put many "identical" chunks in the
ValueChunksTable. We can improve the representation by adding a field to
the chunk that tells the number of chunks with this values i.e. store
(fa/k, ca/k , UNSPENT , k) with k = gcd(ca,fa) instead of k chunks
(ca,fa,UNSPENT).</p>
</li>
<li>
<p>We should consider the effect of reducing the size of the numbers
with strategies like the one described with respect to the rounding
errors brought by the conversion methods.</p>
</li>
<li>
<p>We can implement the second alternative mentioned about how to
refresh the ValueChunksTable when we have to break a chunk to spend it.
We could even let an agent change the strategy dynamically.</p>
</li>
</ol>
</div>
</div>
<div class="sect5">
<h6 id="_todo_and_other_notes">TODO and Other Notes</h6>
<div class="ulist">
<div class="title">Think</div>
<ul>
<li>
<p>¿Cada cuanto se actualiza el index the intercambios?</p>
</li>
<li>
<p>¿qué hacer si entre la consulta sobre el descuento y la compra efectiva la tasa de cambio varía? Esto podría verse como algo raro en la Discount Wallet.</p>
</li>
<li>
<p>En la actualización de las tablas al romper un chunk.
Le coloco que el credit que creó a los hijos es el del padre o lo dejo null?</p>
</li>
<li>
<p>Precios de compra y de venta, interfaz de CryptoIndexManager</p>
</li>
<li>
<p>Qué significa el timestamp de un value chunk?
Si es el momento de creación entonces hay que cambiar que en el debit que
implementé no se modifique el timestamp de los value chunks originales</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">TODO</div>
<ul>
<li>
<p>All the logic described here is already implemented.</p>
</li>
<li>
<p>To finish the implementation we need to correct the pluginRoot, also
the databaseFactory (it should try to open the database before creating
it)</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_discount_wallet_2">Discount Wallet</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_16">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="BasicWallet-BitcoinWallet-BitDubai-V1">Version 1</h5>
<div class="sect5">
<h6 id="_plug_in_description_5">Plug-in Description</h6>
<div class="paragraph">
<p>Como las demás wallets de la capa de Basic Wallet, este plugin lleva el balance de su niche wallet asociada.<br>
En este caso el balance puede fragmentarse en dos conceptos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Available Balance: Es la cantidad de bitcoins que el usuario tiene disponible en el momento para
manipular (gastar).</p>
</li>
<li>
<p>Book Balance: Es la cantidad de bitcoins que están siendo manejadas por la wallet.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El book balance puede diferir temporalmente del available balance. Por ejemplo, cuando llegan bitcoins a
una wallet, la red bitcoin nos avisa de la llegada de crypto currency apenas se ve en la red una
transacción que se dirige a nuestra wallet. Sin embargo, hasta que la transacción no entra en un bloque
no tenemos forma de utilizar estos bitcoins. Queremos que el usuario pueda ver que la transacción se está
procesando por la red y actualizarle su balance, pero al mismo tiempo queremos impedir que pueda gastarlo.<br>
El procedimiento para este tipo de situación en un sistema contable es registrar en el book balance estos bitcoins
detectados que aún no se confirmaron y luego de que entren en un bloque sean ingresados al available balance.<br>
En el período de tiempo entre que se identifica la transacción entrante y se confirma por la red, tendremos que el
book balance tendrá más bitcoins que el available balance.<br>
Otro ejemplo sobre las situaciones en que estos dos balances difieren es al momento de hacer un débito.<br>
Cuando enviamos un débito, este será descontado del available balance y no se descontará del book balance hasta que
no se confirme el envío exitoso de la transacción.<br></p>
</div>
<div class="paragraph">
<p>Por lo tanto, esta wallet deberá permitirnos manejar créditos (ingresos), débitos (egresos) y consultas de balance
de ambos tipos de balances.<br></p>
</div>
<div class="paragraph">
<p>A nivel del sistema, la modificación al book balance y la modificación al available balance son dos
transacciones distintas. La wallet deberá llevar una lista de todas las transacciones que se realizan
(sean del book balance o del availbable balance).<br></p>
</div>
<div class="paragraph">
<p>Notemos entonces que como vamos a tener una tabla de transacciones, requeriremos que la clave primaria
de la misma ya no sea el hash de la transacción bitcoin asociada, sino un UUID diferente.<br>
Analicemos esto con un ejemplo:</p>
</div>
<div class="paragraph">
<p>Una transacción entrante es detectada por el módulo de la red bitcoin, los módulos transaccionales
son notificados por la red y aplican en el book balance la transacción correspondiente asociada
a esta transacción bitcoin entrante.<br>
Unos minutos más tarde, llega un aviso de la red bitcoin comunicando que la transacción fue confirmada,
por lo que los módulos transaccionales aplican en el available balance la actualización correspondiente.<br>
Notemos que en la tabla de las transacciones se ingresarán dos registros para la misma transacción bitcoin,
el que registró la identificación de la transacción y el que refistró su confirmación.<br>
Ambas transacciones (de fermat, es decir, registros de la tabla de transacciones de la bitcoin wallet)
están asociadas a la misma transacción bitcoin, es por esto que no podemos usar el hash de la transacción
bitcoin como clave primaria de la tabla de transacciones.</p>
</div>
<div class="paragraph">
<p>Por cuestiones de optimización queremos que el cálculo de ambos balances se lleve en una tabla de la
base de datos del plugin. Esta tabla tendrá dos columnas, una para el Book Balance y otra para el
Available Balance.<br>
Cuando se haga un débito/crédito en alguno de los balances se restará/sumará el monto a estos valores
que están en la tabla. La tabla siempre tendrőa un őunico registro<br></p>
</div>
<div class="paragraph">
<p>Por otro lado, en la tabla de transacciones, queremos llevar dos valores de información más. Estos valores
serán el Running Book Balance y el Running Available Balance, los cuales registran los balances acumulados
hasta el momento de la transacción.<br>
Por ejemplo, si teníamos 2 BTC en el Book Balance y la misma cantidad en el Available Balance y se ejecuta
el método de credit sobre el Book Balance registrando el ingreso de 1 BTC tendremos que en el campo de Running
Book Balance figurarán 3 BTC mientras que en el de Running Available Balance dirá 2 BTC.<br>
Si luego entra otra transacción al Book Balance de 2 BTC, se ingresará la nueva transacción con valores de
Running Book Balance de 5 BTC y el Running Available Balance seguirá siendo de 2 BTC.<br>
Cuando se ejecute el credit del Available Balance para alguna de estas transacciones, se ingresara una
treansaccion que tendrá como Running Book Balance el Book Balance actual y como Available Book Balance
el Available Book Balance actual más el monto de la transacción crypto asociada.<br></p>
</div>
</div>
<div class="sect5">
<h6 id="_plug_in_structure">Plug-in Structure</h6>
<div class="paragraph">
<p>La estructura de este plugin seguirá la estructura de nuestra descripción.<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p>El plugin root tendrá un método que retorna una Bitcoin Wallet a partir de un Id.</p>
</li>
<li>
<p>La bitcoin wallet tendrá un método que retorne las transacciones, este tendrá dos parámetros, el
offset y la cantidad máxima de transacciones que se desean traer. Además deberá tener un método que
retorne un objeto que permita hacer el débito, crédito y consulta de balance del Book Balance y otro
método que retorne un objeto con igual interfaz pero que realice las operaciones sobre el Available
Balance.<br></p>
</li>
<li>
<p>Los objetos que manipulan el Available y Book Balance actuarán sobre un objeto intermedio que será
quién administre las tablas de la base de datos.<br></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_events">Events</h6>
<div class="paragraph">
<p>Al actualizar satisfactoriamente los balances debemos informar al sistema que hubo una actualización
de los mismos, para ello dispararemos dos eventos.<br></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">BitcoinWalletAvailableBalanceChangedEvent</dt>
<dd>
<p>Este evebto debe lanzarse cuando el Available Balance es
alterado tras una operación de crédito o débito.</p>
<div class="dlist">
<dl>
<dt class="hdlist1">BitcoinWalletBookBalanceChangedEvent</dt>
<dd>
<p>Este evento debe lanzarse cuando el Book Balance es alterado
tras una operación de crédito o débito.</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="_implementation_details">Implementation Details</h6>
<div class="paragraph">
<p>Cuando llega una transacción a aplicar debemos registrar la misma en la tabla de transacciones.<br>
Para completar los campos de la tabla debemos calcular el Running Book Balance y el Available Book
Balance, lo cual involucra:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Consultar el balance actual.</p>
</li>
<li>
<p>Dependiendo si es un crédito en el Book o Available Balance, sumar al campo del Running Balance
correspondiente el monto de la transacción.</p>
</li>
<li>
<p>Actualizar el balance actual.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Esto trae un problema que ilustraremos con el siguiente ejemplo:</p>
</div>
<div class="paragraph">
<p>Supongamos que el balance actual del es 2 BTC de Book Balance y también 2 BTC del Available Balance.
Usermos la notación de pares ordenados (Book Balance, Available Balance) para simplificar la notación.
Es decir, que tenemos un balance (2,2).<br>
Supongamos que un thread pide hacer un crédito de 1 BTC al Book Balance. Lo intuitivo es que el thread que
ejecute el primer crédito registrará una transacción con Running Book Balance de 3 BTC y balance (3,2), mientras
que el segundo thread dejará un Running Book Balance de 4 BTC y un balance de (4,2). Sin embargo, podría
darse la siguiente secuencia:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El primer thread llama al credit. Lee que el balance es (2,2)</p>
</li>
<li>
<p>Antes de que el primer thread complete su operación de actualizar el balance, el segundo thread llama
al método de credit y también lee un balance de (2,2).</p>
</li>
<li>
<p>El primer thread actualiza las tablas y coloca que su Running Book Balance es de (3,2), es decir,
el balance que leyó más 1 BTC que era el monto de la transacción.</p>
</li>
<li>
<p>El segundo thread también actualiza las tablas y como leyó un balance (2,2) también coloca una transacción
con Running Book Balance de 3 BTC y balance (3,2)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Como vemos se pierde una transacción en los balances.<br>
Vamos a necesitar que se puedan realizar estas actualizaciones de manera transaccional por lo que
debemos realizar cambios al plugin de base de datos. Posiblemente lo más adecuado sea poder hacer una
lectura dentro de una transacción así como se realizan updates e inserciones.<br></p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Fermat-DMP-CryptoTransactionLayer">Crypto Transaction Layer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="Fermat-DMP-CryptoTransactionLayer-LayerDescription">Layer Description</h3>
<div class="paragraph">
<p>Transactions are one of the core functionalities developed over Fermat.<br>
Fermat uses crypto currencies to transfer the real value from a user to another, but we have to remember that you can make transactions of other assets apart from crypto currencies.<br>
For example, we can transfer 100 dollars from one wallet to another. The mechanism to do this involve the value transaction which is managed by transferring an amount of crypto currency like bitcoin equivalent to 100 dollars between the users and an information transaction which provide the information about the meaning of those bitcoins. In this case the information would be that the bitcoins sent by the crypto network are represented as 100 dollars.<br></p>
</div>
<div class="paragraph">
<p>Therefore, when we make a transaction in Fermat we can identify two components: <strong>meta data</strong> and <strong>value</strong>.<br>
The value at this moment is stored at a crypto vault, specifically under a crypto addresses managed managed by the vault plugin. On the other hand the information tell us, among other things, which and how much fiat currency or other asset is beign transmitted.<br></p>
</div>
<div class="paragraph">
<p>The meta data and the value travel through different channels, so they will be be acknowledged by a device at different moments in time. This means that we can receive a notification that 100 dollars have been sent to us before we get any new bitcoins that represent the value or vice versa, we can get new bitcoins before receiving the notification of what those bitcoins represent and why they have been sent.<br></p>
</div>
<div class="paragraph">
<p>The responsibility of this layer is to keep these concepts synchronized and within each device the transactional and balance information in a consistent state. The plug-ins that live here detect the arrival of value and information and will update the balances of the system vaults and wallets in an atomic transactional way, i.e. they will update things only when both meta data <strong>and</strong> value are acknowledged.<br>
No loss of value nor meta data can be permitted. The mechanisms implemented by this layer will need to contemplate many different kinds of problems (device shut down, network failure, etc.).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The plug-ins in this layer will need to communicate with the wallets and crypto vaults using events or at least a more complex mechanism that simple method call. The plug-ins need to know that the information inside the wallets and volt was actually updated and persisted before ending the synchronization protocol.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the next section we will explore a general idea behind the protocols and failures considered in the design of this layer.</p>
</div>
</div>
<div class="sect2">
<h3 id="_transaction_data_structure">Transaction Data Structure</h3>
<div class="paragraph">
<p>To attack the problems we deal with in this layer we will need to design a few data structures to contain and share important information.<br>
To simplify the analysis let&#8217;s give a name to the data strcutures that contains the value and information associated to the fermat transaction. We will call them TransactionInformation and MetaTransactionInformation respectively.<br></p>
</div>
<div class="paragraph">
<p>As we will get the value and meta-value separetely and in no predictable order we will introduce in the MetaTransactionInformation a reference to the associated TransactionInformation. In this way we will be able to know when we have all the information needed to reflect the transaction in the wallets among other components.<br></p>
</div>
<div class="paragraph">
<p>The TransactionInformation will store.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The crypto currency we are dealing with as value.</p>
</li>
<li>
<p>The amount of crypto currency.</p>
</li>
<li>
<p>A transaction identifier that distinguish the crypto transaction.</p>
</li>
<li>
<p>The source crypto address of the transaction.</p>
</li>
<li>
<p>The destination crypto address of the transaction.</p>
</li>
<li>
<p>The timestamp that stablish the creation time of the transaction.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
In a single crypto transaction could be bundled many meta transactions. (Think for the future)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The MetaTransactionInformation will store:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The asset represented by the transaction (fiat currency, bonds, etc)</p>
</li>
<li>
<p>A representation of relevant information associated to the asset, e.g. in fiat currency would be the amount of currency involved.</p>
</li>
<li>
<p>The transaction identifier of the associated TransactionInformation.</p>
</li>
<li>
<p>The timestamp that stablish the creation time of the transaction.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
We could consider as a simple secutiry mechanism to ask for this timestamp to be the same timestamp present in the associated TransactionInformation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This cointainers descriptions are a draft presentation. We will add some fields to them to attack the syncronization problems.<br></p>
</div>
<div class="paragraph">
<p>An important aspect to consider is that lower layers (like network services and crypto networks) will interact with this containers as they are the layers that will give us this information.<br></p>
</div>
</div>
<div class="sect2">
<h3 id="Fermat-DMP-CryptoTransactionLayer-TransactionTransferProtocol">Transaction Transference Protocols</h3>

</div>
<div class="sect2">
<h3 id="_transaction_transference_protocol_version_1">Transaction Transference Protocol - Version 1</h3>
<div class="paragraph">
<p>Date: May 6th 2015<br>
Author: Ezequiel Postan &lt;<a href="mailto:ezequiel_postan@hotmail.com">ezequiel_postan@hotmail.com</a>&gt;</p>
</div>
<div class="paragraph">
<p>Este protocolo involucra dos tipos de módulos T y R. Los tipo T transfieren la responsabilidad de transacciones que poseen y los tipo R reciben la responsabilidad de las transacciones. El tener la responsabilidad significa que deben realizar alguna tarea con la información de la transacción transmitida.<br></p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Este protocolo asume que los módulos tipo R saben quienes son sus T asociados (quienes les transmiten transacciones). Los módulos tipo T no conocen la ideantidad de los R, sin embargo es posible que un módulo de tipo T deba clasificar transacciones y entregar distintos grupos a distintos receptores o dar la opción de dar distintos gruposa un mismo receptor. Presentaremos primero el caso de un sólo emisor y receptor y luego agregaremos leves adaptaciones para adaptarnos al caso más general.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sean T un módulo de tipo T y R un módulo de tipo R.
Debemos considerar algunas cosas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>T puede realizar otras acciones previas a inicar el traspaso de la transación.</p>
</li>
<li>
<p>R puede realizar alguna tarea tras recibir la transacción.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Para tener esto en cuanta en los pasos del protocolo, a cada transacción se le agregará un estado de la transacción y un estado de notificación, que notaremos como un par (ESTADO_DE_TRANSACCIÓN, ESTADO_DE_NOTIFICACIÓN).<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p>El estado de la transacción podrá ser: ACKNOWLEDGED, RESPONSIBLE, DELIVERED o APPLIED.</p>
</li>
<li>
<p>El estado de la notificación será NO_ACTION_REQUIRED, TO_BE_NOTIFIED, RECEPTION_NOTIFIED o SENDING_NOTIFIED.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El significado y uso de cada estado se explicará a continuación junto con el protocolo.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Cuando digamos que T recibe/registra una transacción nueva, nos referimos a que tiene una nueva transacción que procesar.
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<div class="title">Pasos del protocolo</div>
<ol class="arabic">
<li>
<p>T registra una transacción nueva que debe procesar, entonces la guarda en su base de datos interna con el par de estados (RESPONSIBLE, NO_ACTION_REQUIRED).</p>
</li>
<li>
<p>Cuando T (siguiendo su lógica interna) concluye que debe enviar transacciones que están en el estado (RESPONSIBLE,NO_ACTION_REQUIRED) a otro módulo (que será de tipo R), pasa a estas transacciones al estado   (RESPONSIBLE, TO_BE_NOTIFIED).</p>
</li>
<li>
<p>Periódicamente T revisa si tiene transacciones en la combinación (RESPONSIBLE,TO_BE_NOTIFIED) o (RESPONSIBLE, SENDING_NOTIFIED).</p>
<div class="ulist">
<ul>
<li>
<p>Si tiene transacciones en alguno de esos pares de estados, envía el evento TransactionsWaitingTransferenceEvent, para que un módulo responsable se haga cargo y <strong>luego de envíar el evento</strong> pasa las transacciones del estado (RESPONSIBLE,TO_BE_NOTIFIED) al estado (RESPONSIBLE, SENDING_NOTIFIED), las que ya estaban en SENDING_NOTIFIED no cambian su estado.</p>
</li>
<li>
<p>Si no tiene transacciones en ese estado sigue con el análisis del resto de las transacciones.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Por otro lado, cuando R escucha el evento que lanzó T, mira que el origen del evento es T y llama a un método de la interfaz de T que retorna una lista con todas las transacciones que tiene guardadas en estado (RESPONSIBLE, SENDING_NOTIFIED). <strong>T no cambia el estado de las transacciones que tiene almacenadas cuando R hace esta consulta.</strong></p>
</li>
<li>
<p>R recorre la lista y almacena en una base de datos interna cada transacción de a una a la vez con el estado (ACKNOWLEDGED, TO_BE_NOTIFIED).</p>
</li>
<li>
<p>Luego, para cada transacción en estado (ACKNOWLEDGED, TO_BE_NOTIFIED) en su base de datos, R llama a otro método de T al cual le pasa el ID de la transacción. La ejecución de este método marca en la base de datos <strong>de T</strong> a dicha transacción como (DELIVERED, RECEPTION_NOTIFIED). <strong>Luego de esa llamada al método de T</strong>, <strong>R</strong> marca la transacción en estado (RESPONSIBLE, RECEPTION_NOTIFIED).</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
El motivo por el cual primero se notifica y luego se confirma se hace para garantizar que la transacción fue correctamente confirmada por T antes de marcar que lo fue en la base de datos de R.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Aquí termina el protocolo de traspaso simple, pero podemos considerar un paso extra para contemplar la acción que realiza R sobre las transacciones recibidas.</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="7">
<li>
<p>R toma las transacciones en estado (RESPONSIBLE, RECEPTION_NOTIFIED) y realiza su tarea. <strong>Luego de aplcar la tarea</strong> las pasa a (APPLIED, RECEPTION_NOTIFIED)</p>
</li>
</ol>
</div>
<div id="Fermat-DMP-CryptoTransactionLayer-TransactionTransferProtocol-TransactionSenderAprox" class="ulist">
<div class="title">NOTAS DEL PROTOCOLO</div>
<ul>
<li>
<p>Dado que mencionamos dos métodos de T, podemos definir una interfaz llamada <code>TransactionsSender</code> que los identifique.</p>
<div class="ulist">
<ul>
<li>
<p><code>List&lt;TransactionInformation&gt; getPendingTransactions()</code> para obtener la lista de transacciones a traspazar</p>
</li>
<li>
<p><code>void confirmReception(TransactionID x)</code> para comunicar la recepción de una transacción.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Para la versión final del protocolo esta interfaz se modificará levemente.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Cuando se involucra sólo a dos módulos (uno de tipo R y otro T), este protocolo se implementa con tres agentes en T y otros tres en R.</p>
<div class="ulist">
<ul>
<li>
<p>El main thread de T es quien implementa la interfaz de transacciones de T (los métodos.</p>
</li>
<li>
<p>En primer agente de T es quien monitorea la aparición de nuevas transacciones y las escribe en una tabla con el estado (RESPONSIBLE, NO_ACTION_INTENDED).</p>
</li>
<li>
<p>El segundo agente mira esa tabla, ejecuta una lógica interna y cuando determina que deben traspasarse las transacciones a otro módulo pasa las transacciones correspondientes del estado (RESPONSIBLE, NO_ACTION_INTENDED) a (RESPONSIBLE, TO_BE_NOTIFIED).</p>
</li>
<li>
<p>El tercer agente es quien se despierta periódicamente, y cuando encuentra transacciones en estado (RESPONSIBLE, TO_BE_NOTIFIED) o (RESPONSIBLE, SENDING_NOTIFIED) envía el evento TransactionsWaitingTransferenceEvent y marca las que eran TO_BE_NOTIFIED como (RESPONSIBLE, SENDING_NOTIFIED). <strong>Notar que sigue en estado RESPONSIBLE</strong>.</p>
</li>
<li>
<p>El main thread de R es quien recibe los eventos de T y los registra en una base de datos interna.</p>
</li>
<li>
<p>El primer agente lee los eventos de esta base de datos que llena el main thread, va a buscar la lista de transacciones a T y las guarda una por una en otra tabla de la base de datos con el estado (ACKNOWLEDGED, TO_BE_NOTIFIED).</p>
</li>
<li>
<p>El segundo agente mira la tabla que llena el agente anterior con transacciones nuevas y le informa a T que recibió correctamente las transacciones de a una a la vez (a través del método <code>confirmReception</code>). Entonces, <strong>tras confirmarle a T la recepción</strong> pasa la misma al estado (RESPONSIBLE, NOTIFIED).</p>
</li>
<li>
<p>El tercer agente aplica la tarea de R sobre las transacciones (RESPONSIBLE, NOTIFIED) y las pasa al estado (APPLIED, NO_ACTION_REQUIRED).</p>
</li>
</ul>
</div>
</li>
<li>
<p>Si nos paramos en una sola tranacción vemos este ciclo de estados en las tablas de T y R.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>
            T         R
   1      (R,NAR)
   2      (R,TBN)
   3      (R,SN)
   4                (AC,TBN)
   5      (D,RN)
   6                (R,RN)
   7                (AP,RN)

   Referencias:
   R: RESPONSIBLE        NAR: NO_ACTION_REQUIRED
   D: DELIVERED          TBN: TO_BE_NOTIFIED
   AC: ACKNOWLEDGE       SN: SENDING_NOTIFIED
   AP: APPLIED           RN: RECEPTION_NOTIFIED</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#Fermat-DMP-CryptoTransactionLayer-TransactionTransferProtocol-SBDProtocol">Más adelante</a> hablaremos del caso de una comunicación que involucra tres módulos, uno de tipo T (emisor original), uno de tipo R (receptor final) y un módulo intermedio que actúa como tipo R para el emisor original y como tipo T para el receptor final (un puente).</p>
</li>
<li>
<p>Al iniciarse un módulo de tipo R, deberá consultar si sus módulos T asociados tienen transacciones acumuladas. Esto se debe a que el módulo pudo inicializarse tras haber perdido varias notificaciones de transacciones nuevas.</p>
</li>
<li>
<p>Claramente puede llegar una nueva transacción a T antes que R procese toda la lista de transacciones que ha recibido en una consulta anterior. En este caso T podría disparar nuevamente el evento de que avisa que tiene nuevas transacciones.<br>
El primer thread de R recibirá ese evento, y luego el segundo thread probablemente traerá, en la lista de transacciones nueva, transacciones que ya ha registrado pero aún el tercer thread no ha confirmado recepción.<br>
Esto da lugar a que se intente guardar en la base de datos una transacción ya almacenada, dicho caso no deberá considerarse como un error y simplemente deberá ser ignorado.<br></p>
</li>
<li>
<p>Por otro lado T debe estar preparado para el aviso de que se desea notificar que una transacción se procesó más de una vez. Esto puede darse en el caso en que el tercer thread de R notificó la recepción pero no llegó a persistir en su base de datos el cambio de estado a NOTIFIED, T ignorará el aviso y si todo es correcto esta vez R sí podrá marcar la transacción como NOTIFIED.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="Fermat-DMP-CryptoTransactionLayer-TransactionTransferProtocol-SBDProtocol">Caso de tres módulos</h4>
<div class="paragraph">
<p>Llamaremos a este caso el Protocolo SBD (Protocolo <strong>S</strong>ource-<strong>B</strong>ridge-<strong>D</strong>estination).<br>
En este caso tenemos tres módulos involucrados en el intercambio de transacciones.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un módulo S de tipo T (emisor original).</p>
</li>
<li>
<p>Un módulo D de tipo R (destinatario final)</p>
</li>
<li>
<p>Un módulo B que es tanto de tipo T como R (puente entre E y R)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La utilidad de este protocolo se da cuando un módulo (S) debe delegar una transacción pero no tiene forma de saber a quién debe hacerlo. En este caso se coloca a un receptor temporal (B) que sí puede determinar quién es el receptor indicado para la transacción (D).<br></p>
</div>
<div class="paragraph">
<p>Las variaciones a incorporar leves. Los módulos S y D actuarán como explicamos antes en el protocolo simple (no saben que hay un puente), el puente "simplemente" hará que su tercer agente (correspondiente al tipo R, o sea el de aplicación) lea la tabla que llena el agente 2 y actúa como un módulo tipo T cuya acción es envíar las transacciones cuando están en estado (RESPONSIBLE, NOTIFIED) en lugar de (RESPONSABLE, TO_BE_NOTIFIED)).<br>
Al esperar que estén en NOTIFIED en lugar de TO_BE_NOTIFIED se garantiza que el traspazo de la transacción de S a B fue completado exitosamente antes de comenzar a transmitir de B a D.</p>
</div>
<div class="paragraph">
<p>Para considerar la distinción de receptores y otros criterios de clasificación, agregaremos dos parámetros al método <code>getPendingTransactions</code> de la interfaz <a href="#Fermat-DMP-CryptoTransactionLayer-TransactionTransferProtocol-TransactionSenderAprox">TransactionSender</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>  List&lt;TransactionInformation&gt; getPendingTransactions(ReceptorType receptorType, TransactionDescription description)</code></pre>
</div>
</div>
<div class="paragraph">
<p>donde <code>receptorType</code> indicará el tipo de receptor al que se le puede entregar la transacción y <code>descriprion</code> será la descripción del tipo de transacciones que debe usarse. Ambos serán enums que encapsulan un string.</p>
</div>
<div class="paragraph">
<p>Revisemos los pasos, el pasaje de las transacciones de S a B es el protocolo normal para mandar de un T a un R.<br>
Así que tenemos que B tiene transacciones después del paso 5 del protocolo. Es decir, con el estado (RESPONSIBLE, RECEPTION_NOTIFIED).<br>
Aquí el paso 7 será que el tercer agente de B decide a quién debe enviar algunas transacciones, las pasa al estado (RESPONSIBLE, TO_BE_NOTIFIED)  (combinación de estados que no se da en el protocolo simple) y marca la transacción con el receptorType adecuado. También anota el evento a lanzar según el análisis realizado.
Un cuarto agente controlará periódicamente si hay transacciones en este estado (RESPONSIBLE, TO_BE_NOTIFIED), lanzará el evento que indicó el thread anterior y pasará la transacción a (RESPONSIBLE, SENDING_NOTIFIED).<br>
La implementación del método <code>confirmReception</code> de B pasará las transacciones de (RESPONSIBLE, SENDING_NOTIFIED) a
(DELIVERED, SENDING_NOTIFIED) cerrando la participación de B.
Cuando D pida las transacciones colocará el receptorType que lo identifica y posiblemente una descripción sobre la transacciones que quiere retirar (por ejemplo que estén en crypto estado identified) como parámetros de <code>getPendingTransaction</code></p>
</div>
<div class="paragraph">
<p>Nuevamente, si nos paramos en una sola tranacción vemos este ciclo de estados en las tablas de T y R.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>
              S         B         D
    1      (R,NAR)
    2      (R,TBN)
    3      (R,SN)
    4               (AC,TBN)
    5      (D,RN)
    6                (R,RN)
    7                (R,TBN)
    8                (R,SN)
    9                          (AC,TBN)
   10                (D,RN)
   11                           (R,RN)
   12                          (AP,RN)

   Referencias:
   R: RESPONSIBLE        NAR: NO_ACTION_REQUIRED
   D: DELIVERED          TBN: TO_BE_NOTIFIED
   AC: ACKNOWLEDGE       SN: SENDING_NOTIFIED
   AP: APPLIED           RN: RECEPTION_NOTIFIED</code></pre>
</div>
</div>
<div class="paragraph">
<p>Estos protocolos serán implementados por diversos plug-ins que interactúan con esta capa.</p>
</div>
</div>
<div class="sect3">
<h4 id="_problemas_a_resolver">Problemas a resolver</h4>
<div class="sect4">
<h5 id="_analizar_livelocks">Analizar livelocks</h5>
<div class="paragraph">
<p>Ejemplo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El tercer agente de T encuentra transacciones en estado (RESPONSIBLE, TO_BE_NOTIFIED) y envía el evento TransactionsWaitingTransferenceEvent. Antes de que actualice la transacción al estado (RESPONSIBLE, SENDING_NOTIFIED) el agente de R se lleva la transacción, la registra y confirma su recepción. Esto lleva a que el estado cambie a (DELIVERED,RECEPTION_CONFIRMED). Finalmente este agente ejecuta la actualización en su thread y escribe el estado de notificación SENDING_NOTIFIED.
Aquí dependemos de la implementación que se haya hecho en el plug-in de databaseManager:</p>
<div class="ulist">
<ul>
<li>
<p>Si se actualizan todos los campos tendremos el estado final (RESPONSIBLE, SENDING_NOTIFIED) y la transacción pasará a ser enviada de nuevo. Para resolver eso deberíamos hacer que los módulos R al recibir varias veces una transacción, no lancen un error pero sí deben llamar de nuevo al método de notificación.</p>
</li>
<li>
<p>Si se actualiza sólo el campo modificado del record se obtendría el estado final (DELIVERED,SENDING_NOTIFIED), lo cual no es del todo un problema pero demuestra que algo simple como esto parece tiene muchos detalles acarreados por la concurrencia.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_no_aplicable">No aplicable</h5>
<div class="paragraph">
<p>Si bien este es un buen inicio, no soluciona el problema. En la versión 2 refinamos las cosas para que se pueda adaptar mejor a cambios.</p>
</div>
</div>
<div class="sect4">
<h5 id="_simplicidad">Simplicidad</h5>
<div class="paragraph">
<p>ESTO DE ABAJO ESTÁ MAL, PORQUE SE MARCA COMO (ACKNOWLEDGE,TO_BE_NOTIFIED) y no como RESPONSIBLE.
Tengo la impresión de que esto anda y que la explicación es entendible y será fácil de entender la implementación tras leer esto. La duda que tengo es que es muy evidente que puedo fusionar algunos threads. Por ejemplo, podría optimizarse la implementación si el agente 1 de R marca la transacción primero como (RESPONSIBLE,TO_BE_NOTIFIED), luego llama a <code>confirrmReception</code> y finalmente cambia la transacción al estado (RESPONSIBLE,RECEPTION_NOTIFIED). Esto permitiría eliminar el agente 2 dado que de todas formas el protocolo está preparado para recibir varias veces la misma transacción (si es que llega a darse que se cae el equipo antes de confirmar la transacción o entre la confirmación y la persistencia en la base de datos (de R) de la confirmación).<br>
La optimización trae dos defectos leves:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Uno semántico es que temporalmente ambos módulos (R y T) tendrán la misma transacción con el estado RESPONSIBLE, en cuyo caso podríamos asumir que ambos son responsables de esa transacción (como dijimos antes, esto no tiene problemas de implementación).</p>
</li>
<li>
<p>El segundo tiene relación con el <a href="#Fermat-DMP-CryptoTransactionLayer-TransactionTransferProtocol-SBDProtocol">protocolo SBD</a>, el cual debería considear nuevos estados para las transacciones y estados de notificación. Pero obviamente puede implementarse.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Habría que ver el análisis fino, si vemos la sección anterior se encuantran posibles trazas que podrían generar problemas. Fusionar threads reduce la concurrencia pero les da más tareas a un mismo thread por lo que las acciones que realiza pueden ser más complejas de analizar.</p>
</div>
</div>
<div class="sect4">
<h5 id="_eventos_esto_se_va_a_mover_a_la_documentaci_n_del_plug_in_incoming_crypto">Eventos (ESTO SE VA A MOVER A LA DOCUMENTACIÓN DEL PLUG-IN INCOMING CRYPTO)</h5>
<div class="paragraph">
<p>Necesitamos hacer que el incoming crypto implemente un puente del protocolo SBP con un evento especial para avisarle a los incoming crypto especializados que le pidan transacciones nuevas.<br>
Por lo que veo hay que hacer que el método <code>getPendingTransactions</code> tome un parámetro que diga qué destino tienen las transacciones. Así quién recibió el evento se lleva las que les corresponde y no las de otros.</p>
</div>
<div class="paragraph">
<p>Para los estados de las crypto noté que hay eventos especializados como</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IncomingCryptoIdentifiedFromIntraUserEvent</p>
</li>
<li>
<p>IncomingCryptoIdentifiedFromExtraUserEvent</p>
</li>
<li>
<p>&#8230;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por lo que probablemente habrá usaremos dichos eventos.<br>
Hay que modificar las cosas para poder mandar y coordinar la comunicación del crypto estado de cada transacción (Identified, received, etc), esto lo veremos en la versión 2 y dejamos esto como guía/borrador de referencia.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_transaction_transference_protocol_version_2_draft">Transaction Transference Protocol - Version 2 (DRAFT)</h3>
<div class="paragraph">
<p>Date: Jun 6th 2015<br>
Author: Ezequiel Postan &lt;<a href="mailto:ezequiel_postan@hotmail.com">ezequiel_postan@hotmail.com</a>&gt;</p>
</div>
<div class="sect3">
<h4 id="_consideraciones">Consideraciones</h4>
<div class="ulist">
<ul>
<li>
<p>No se puede depender sólo de los eventos informativos IncomingCryptoReceivedEvent e IncomingCryptoReversedEvent porque pueden detectarse transacciones crypto confirmadas sin que haya visto la primer confirmación (porque estaba apagado el equipo por ejemplo). El protocolo de traspaso de transacciones sólo depende de un evento que exige el traspaso de transacciones pendientes, usaresmo el evento IncomingCryptoTransactionsWaitingTransferenceEvent.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_problemas_de_la_versi_n_1">Problemas de la versión 1</h4>
<div class="ulist">
<ul>
<li>
<p>No separaba los conceptos de transacción de la red crypto y transacción de la plataforma. Cosa que notaremos más adelante.</p>
</li>
<li>
<p>No plantea cómo organizar las cosas para reutilizar el protocolo para comunicar MetaTransactionInformation provenientes de los network services.</p>
</li>
<li>
<p>Problema "menor", podría ser más eficiente</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_definiciones_preliminares">Definiciones preliminares</h4>
<div class="dlist">
<dl>
<dt class="hdlist1">Agente</dt>
<dd>
<p>Thread que realiza un trabajo en paralelo.</p>
</dd>
<dt class="hdlist1">Transacción crypto</dt>
<dd>
<p>Mecanismo por el cual una red de crypto currencies registra el traspaso de valor de un usuario a otro.</p>
</dd>
<dt class="hdlist1">Transacción</dt>
<dd>
<p>Tarea de modificar los estados de las wallets y crypto volt de manera transaccional</p>
</dd>
<dt class="hdlist1">CryptoStatus</dt>
<dd>
<p>Enum que lista los posbles estados de una transacción crypto. Estos son:</p>
<div class="ulist">
<ul>
<li>
<p>PENDING_SUBMIT: Cuando la transacciòn se creó internamente, pero aún no fue distribuida en la red de Bitcoin. Este estado es importante sólo para las transacciones salientes.</p>
</li>
<li>
<p>ON_CRYPTO_NETWORK: Cuando se ve la transacción crypto en la red pero sin ninguna confirmación</p>
</li>
<li>
<p>ON_BLOCKCHAIN: Cuando la transacción crypto obtiene la primer confirmación.</p>
</li>
<li>
<p>IRREVERSIBLE: Cuando la tramsacción crypto obtiene suficientes confrmaciones para considerar la transacción irreversble.</p>
</li>
<li>
<p>REVERSED: Cuando se reverte la transacción.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Specialist</dt>
<dd>
<p>Enum que lista qué tipo de plug-in debe tomar poseción de la transacción a traspazar. Este enum es necesario dado que este plug-in debe dar distintas transacciones a distintos plug-ins, por ende cuando un plug-in venga a tomar posesión de una transacción debe indicar qué tipo de transacciones maneja.</p>
</dd>
<dt class="hdlist1">CryptoTransaction</dt>
<dd>
<p>Contenedor de datos con la información de una transacción. Esta información es:</p>
<div class="ulist">
<ul>
<li>
<p>Hash de la transacción</p>
</li>
<li>
<p>Dirección de Origen</p>
</li>
<li>
<p>Dirección de Destino</p>
</li>
<li>
<p>Crypto Currency</p>
</li>
<li>
<p>CryptoState</p>
</li>
<li>
<p>Monto</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Transaction</dt>
<dd>
<p>Contenedor de datos con la información de una transacción. Estos datos son:</p>
<div class="ulist">
<ul>
<li>
<p>Un identificador distintivo (TransactionId)</p>
</li>
<li>
<p>Un elemento de tipo CryptoTransaction</p>
</li>
<li>
<p>Un valor de Specialist (los receptores de transacciones crypto pueden colocar en este campo el valor CRYPTO_ROUTER para mencionar al incomingcrypto)</p>
</li>
<li>
<p>Un timestamp que coloca quien genera la transaccón. (En este caso la red bitcoin)</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">TransactionStatus</dt>
<dd>
<p>Estado interno que guarda un plug-in sobre cadaa transacción que describe su relación con la misma. El estado puede ser:</p>
<div class="ulist">
<ul>
<li>
<p>ACKNOWLEDGE: Cuando recibe una transacción pero aún no confirmó su recepción.</p>
</li>
<li>
<p>RESPONSIBLE: Cuando posee la transacción y aún no la aplicó ni la traspasó</p>
</li>
<li>
<p>DELIVERED: Cuando traspasó la transacción a otro plug-in para que este se haga responsable.</p>
</li>
<li>
<p>APPLIED: Cuando aplicó la transacción</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">ProtocolStatus</dt>
<dd>
<p>Estado interno que guarda un plug-in sobre cada transacción que describe su situación de traspaso de la misma. Este estado puede ser:</p>
<div class="ulist">
<ul>
<li>
<p>NO_ACTION_REQUIRED: Cuando se tiene una transacción pero no se requiere ejecutar ningún traspaso o aplicación aún.</p>
</li>
<li>
<p>TO_BE_NOTIFIED: Cuando se debe notificar un evento para iniciar el traspaso de una transacción.</p>
</li>
<li>
<p>SENDING_NOTIFIED: Cuando se emitió el evento que notifica el pedido de traspaso de la transacción.</p>
</li>
<li>
<p>RECEPTION_NOTIFIED: Cuando se recibe la confirmación de receptión del traspaso de una transacción.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">TransactionSender</dt>
<dd>
<p>Interfaz que implementan los plug-ins que traspasan transacciones a otros módulos, brinda los siguientes métodos:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>  void confirmReception(TransactionId transactionId)
  List&lt;Transaction&gt; getPendingTransactions(Specialist specialist)</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>El método confirmedReception marca la transacción marcada como argumento como (DELIVERED,RECEPTION_NOTIFIED).
El método getPendingTransactions retorna la lista de todas las transacciones con ProtocolStatus SENDING_NOTIFIED que tienen como Specialist al pasado como argumento. Notar que no camba el estado de ninguna transacción.</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Respetar que <code>getPendingTransactions</code> retorne sólo lo que está en estado (RESPONSIBLE,SENDING_NOTIFIED). No intentar "optimizar" pasando las transacciones en TO_BE_NOTIFIED porque traería graves problemas de concurrencia.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Por cuestiones de concurrencia y reutilización de código la interfaz cambiará levemente en la implementación, ver <a href="#Transaction-Transference-Protocol-v2-ImplementationNotes">notas de implementación</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_convensiones">Convensiones</h4>
<div class="ulist">
<ul>
<li>
<p>Escribiremos que una transacción tiene un estado (TS,PS) para describir que su TransactionStatus
es TS y el ProtocolStatus es PS.</p>
</li>
<li>
<p>Dada una transacción crypto, una transacción asociada es una transacción que tiene como
CryptoTransaction un contenedor con los datos de la transacción crypto. Notar que una misma
transacción crypto puede tener más de una transacción asociada. Esto se da por ejemplo cuando,
al detectar que una transacción es confirmada por primera vez se genera un objeto Transaction, y si
esta transacción crypto se reversa generará un nuevo objeto transaction. La duferencia entre ambos
objetos será primero el identificador de la transacción y por otro lado la transacción crypto que
contiene el objeto tendrá un crypto estado distinto.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_protocolo">Protocolo</h4>
<div class="paragraph">
<p>Para simplificar la explicación supondemos que el receptor de las transacciones crypto y por ende el emisor original de las transacciones es el plug-in de la red bitcoin. A su vez, usaremos el término <em>red bitcoin</em> para referirnos a este plug-in. El plug-in al que traspasa las transacciones la red btcoin será el IncomingCrypto y el plug-in que aplicalas transacciones el el IncomingCryptoExtraUser.</p>
</div>
<div class="paragraph">
<p>Analicemos los pasos del protocolo de traspaso de transacciones en estos componentes.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Cuando la red bitcoin despierta, revisa las transacciones <strong>nuevas</strong> que han llegado por la red. Al analizar el crypto estado de cada transacción crypto se tendrá varias opciones:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Si el crypto estado es ON_CRYPTO_NETWORK, almacena una transacción asociada con estado (APPLY,RESPONSIBLE,TO_BE_NOTIFIED)</p>
</li>
<li>
<p>Si el crypto estado es ON_BLOCKCHAIN, almacena una transacción asociada con estado (APPLY,RESPONSIBLE,TO_BE_NOTIFIED)</p>
</li>
<li>
<p>Si el crypto estado es REVERSED, almacena una transacción asociada con estado (REVERT,RESPONSIBLE,TO_BE_NOTIFIED). <a href="#Transaction-Transference-Protocol-v2-Note1">VER NOTA</a></p>
</li>
</ol>
</div>
</li>
<li>
<p>Un agente de la red bitcoin detecta que hay transacciones crypto con ProtocolStatus TO_BE_NOTIFIED o SENDING_NOTIFIED, entonces envía el evento IncomingCryptoTransactionsWaitingTransferenceEvent.
Luego de lanzar el evento marca las transacciones que tenía en TO_BE_NOTIFIED como SENDING_NOTIFIED. <a href="#Transaction-Transference-Protocol-v2-Note2">VER NOTA</a></p>
</li>
<li>
<p>El IncomngCrypto regstra el evento.</p>
</li>
<li>
<p>El MonitorAgent (un agente) del IncomingCrypto ve que hay transacciones pendientes y llama al método <code>getPendingTransactions(CRYPTO_ROUTER)</code> de la fuente que emitió el evento, luego recorre la lista que devuelve y <strong>primero guarda en su base de datos</strong> a todas las transacciones colocándoles el estado (ACKNOWLEDGE,TO_BE_NOTIFIED). <strong>Luego</strong>, por cada transacción en la base de datos con estado (ACKNOWLEDGE,TO_BE_NOTIFIED) (que pueden ser más que las que guardó recién) ejecuta los siguientes pasos <strong>en ese orden</strong>:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Llama al método <code>confirmReception</code> con el TransactionId de la transacción como parámetro.</p>
</li>
<li>
<p>Marca la transacción como (RESPONSIBLE,NO_ACTION_REQUIRED).</p>
</li>
</ol>
</div>
</li>
<li>
<p>El RelayAgent (un segundo agente) del IncomingCrypto analizará las transacciones con estado (RESPONSIBLE,NO_ACTION_REQUIRED). Por cada una de ellas haría los siguientes pasos <strong>en el orden enunciado</strong></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Deduciría a partir de la información de las mismas su Specialist y lo marcaría.</p>
</li>
<li>
<p>Pasaría la transacción al estado (RESPONSIBLE,TO_BE_NOTIFIED)</p>
</li>
<li>
<p>Cuando termina de recorrer la lista recorre ahora todas las que están con TransactonStatus RESPONSIBLE y ProtocolStatus TO_BE_NOTIFIED o SENDING_NOTIFIED. Registra todos los especialistas que vio en <strong>este recoorido</strong> (no intentar optimizar usando el recorrido anterior porque puede perderse si el sistema se cae) y realiza los siguente pasos <strong>en el orden enunciado</strong>:</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Por cada Specialist registrado en el recorrido anterior lanza el evento correspondiente (IncomingCryptTransactionsWaitingTransference<em><strong>Specalist</strong></em>Event)</p>
</li>
<li>
<p>Pasa cada transacción con ProtocolStatus TO_BE_NOTIFIED a SENDING_NOTIFED. <a href="#Transaction-Transference-Protocol-v2-Note3">VER NOTA</a></p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>EL incomng crypto extra-user escuchará el evento.</p>
</li>
<li>
<p>El MonitorAgent (un agente) del IncomingCryptoExtraUser ve que hay transacciones pendientes y llama al método <code>getPendingTransactions(EXTRA_USER)</code> del IncomingCrypto, luego recorre la lista que devuelve y <strong>primero guarda en su base de datos</strong> a todas las transacciones asignándoles el estado (ACKNOWLEDGE,TO_BE_NOTIFIED). <strong>Luego</strong>, por cada transacción en la base de datos con estad (ACKNOWLEDGE,TO_BE_NOTIFIED) (que pueden ser más que las que guardó recién) ejecuta los siguientes pasos <strong>en ese orden</strong>:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Llama al método <code>confirmReception</code> con el TransactionId de la transacción como parámetro, con lo que el IncomingCrypto marcará la transacción que se indique como (DELIVIRED,RECEPTION_NOTIFIED) en la base de datos del IncomingCrypto.</p>
</li>
<li>
<p>Marca la transacción como (RESPONSIBLE,NO_ACTION_REQUIRED).</p>
</li>
</ol>
</div>
</li>
<li>
<p>El RelayAgente (segundo agente) del IncomingCryptoExtraUser ve las transacciones que tiene y decide si debe ejecutarlas o no, <strong>luego de ejecutar la transacción</strong> la marca como (APPLIED,NO_ACTION_REQUIRED)</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_consideraciones_2">Consideraciones</h4>
<div class="paragraph">
<p>El protocolo debe estar preparado para la caída del dispostvo en cualquier paso, por ende las siguientes implementaciones son necesarias.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si un emisor envía el vento para que retiren transacciones y el receptor las retira, almacena, pero el sistema cae antes que pueda confirmarl su receptión termnaremos con este estado:</p>
<div class="ulist">
<ul>
<li>
<p>El receptor tendrá transacciones en su base de datos en (ACKNOWLEDGED,TO_BE_NOTIFIED)</p>
</li>
<li>
<p>El emisor no sabrá que el receptor ya las retiró. Recordar que el receptor sólo retra lo que está en (RESPONSIBLE,SENDING_NOTIFIED).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por ende cuando se levante el sistema, el receptor volverá a pedir transacciones pendientes y recibirá en la lista transacciones que ya tiene. Cuando esto ocurra, el receptor simplemente ignorará la excepción que lanzará la base de datos por querer introducir algo que ya tenemos y procederá a confirmar la recepción de la transacción para que el emisor la saque de la próxima lista a mandar.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si un receptor llama al <code>confirmReception</code> y ants de pasar la transacción de (ACKNOWLEDGED,TO_BE_NOTIFIED) a (RESPONSIBLE,NO_ACTION_REQUIRED) se cae el sistema tendremos la siguiente situación:</p>
<div class="ulist">
<ul>
<li>
<p>El emisor tendrá una transaccón confirmada como (DELIVERED,RECEPTION_NOTIFICED) que el receptor aún tendrá como (ACKNOWLEDGED,TO_BE_NOTIFIED). Por ende no se enviaría en la siguiente lista de transacciones al llamar al método <code>getPendingTransactions</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Es por esto que el agente que toma la lista de transacciones nuevas, tras registrarlas en su base de datos, vuelve a pedirle a la misma <strong>todas</strong> las transacciones en (ACKNOWLEDGED,TO_BE_NOTIFED). Ya que la que se había confirmado pero no registrado confirmación no estaría en la lista obtenida de <code>getPendingTransactions</code>.
Lo que debemos considerar es entonces que cuando se llame al método <code>confirmTransacton</code> más de una vez con la misma transacción, este no lance una excepción sino que simplemente ignore la segunda confirmación para que esta vez el receptor de la transacción pueda pasarla al estado (RESPONSIBLE,NO_ACTION_REQUIRED)</p>
</div>
<div id="Transaction-Transference-Protocol-v2-Note1" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Quiero analizar la posibilidad de cancelar aquí mismo el envío del APPLY de la transacción si aún no se envió, pero es algo tarde cuando escribo esto, voy a verlo al levantarme con mi mente más despierta. A diferencia de la <a href="#Transaction-Transference-Protocol-v2-Note3">últma nota</a> aquí no es tan simple, porque el que notifica es otro thread.
</td>
</tr>
</table>
</div>
<div id="Transaction-Transference-Protocol-v2-Note2" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
DESPUÉS VI ESTO MÁS DESPEJADO Y ME DI CUENTA QUE ESTE PROBLEMA NO SE DA, PORQUE EL MÉRODO <code>getPrndeingTransactions</code> NO ENTREGARÍA TRANSACCIONES EN ESTADO TO_BE_NOTFIED, podría ignorarse esta nota, la dejé para recordarlo yo.<br>
Esto visto en detalle muestra problemas de concurrencia nuevamente, ejemplo: lanzo el evento y el incoming crypto toma las transaccones, las confirma y cuando luego de confirmarlas es que recíen este agente marca la transaccón al estado SENDING_NOTIFED, aquí dependo de cómo esté implementado el módulo de base de datos para saber si esto puede andar mal (no sólo en si la base de datos usa un lock, sino tambien en cuanto a cómo actualiza un campo). Analizado sin mucho detalle creo que podría causar problemas al incorporar los reversed. Creo que con colocar un lock se podría solucionar.<br>
</td>
</tr>
</table>
</div>
<div id="Transaction-Transference-Protocol-v2-Note3" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Acá hay que analizar de nuevo la posibilidad de cancelar el envió de transacciones con acción APPLY si ya tengo registrado el REVERSED. Creo que en este caso puedo cancelar el traspaso si la transaccón tiene ProtocolStatus TO_BE_NOTIFIED.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_conclusiones_hasta_aqu">Conclusiones hasta aquí</h4>
<div class="ulist">
<ul>
<li>
<p>Las consideraciones de cambio que tengo presentes son:</p>
<div class="ulist">
<ul>
<li>
<p>Incorporación de nuevos especalistas</p>
</li>
<li>
<p>Los criterios de decisión se podrían encapsular en clases y usar el patrón de diseño strategy. Pero esto no llegué a verlo.</p>
</li>
<li>
<p>Consultas de informacón: Para que se consulte información, se podría tener uno o más métodos que simplemente no cambien ningún estado interno y retornen la información pedida.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Si parametrizamos el protocolo haciendo que la interfaz TransactionSender tenga un parámetro de tipo genérico podríamos reutilizar el protocolo con otro tipo de transacciones, simplemente cambiaríamos la clase CryptoTransaction por otro contenedor de datos que usarían el emisor y receptor.</p>
</li>
<li>
<p>Parece ser más eficiente porque elimina un par de agentes.</p>
</li>
<li>
<p>Creo que los Network Services que transporten información de valor que deba sincronizarse usarían este protocolo con eventos especializados que indiquen nuevas meta-transacciones.</p>
</li>
<li>
<p>Aún hay que revisar esto y completar los pasos con el incoming-crypto-extra-user y ver si incorporar el incoming-crpyo-intra-user no rompe nada</p>
</li>
<li>
<p>Falta analizar el impacto del cambio de usar una transacción crypto por cada meta transacción a pasar a usar una UTXO por cada meta transacción.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="Transaction-Transference-Protocol-v2-ImplementationNotes">Notas de implementación (IncomingCrypto)</h4>
<div class="paragraph">
<p>Probablemente sea mejor leer primero <a href="#Transaction-Transference-Protocol-v2-NotaParaLuis">esta nota</a></p>
</div>
<div class="sect4">
<h5 id="_opci_n_1_propuesta_en_reuni_n_de_equipo_refinada_por_ezequiel_siguiendo_esa_idea">Opción 1: Propuesta en reunión de equipo, refinada por Ezequiel siguiendo esa idea.</h5>
<div class="ulist">
<ul>
<li>
<p>El incoming crypto usará una clase (Registry) que compartirán los dos agentes de cada módulo. Por cada módulo el registry abritá una copia de la tabla que guarda las transacciones. Esto se hace para evitar problemas de concurrencia.</p>
</li>
<li>
<p>También para solventar problemas de concurrencia, optamos por modificar la interfaz del pluginRoot. En lugar de implementar la interfaz <code>TransactionSender</code> definiremos una interfaz <code>IncomingCryptoManager</code> con el método <code>TransactionSender getTransactionSender(Specialist specialist)</code>.<br>
La implementación de esta interfaz hará que retornemos una copia de la tabla de transacciones actual que lleva el manejador de la base de datos (haremos un open de la tabla para pasar una instancia de la abstracción distinta, lo cual resuelve varias cuestiones de concurrencia).
Además, notemos que podemos parametrizar las Transactions para que transporten otro tipo de datos fuera de transacciones crypto, esto será de utilidad para reutilizar el código. Por último un nombre más adecuado para la interfaz TransactionSender sería TransactionManager, las interfaces finales serán entonces:</p>
<div class="literalblock">
<div class="content">
<pre>public interface IncomingCryptoManager {
  TransactionManager&lt;CryptoTransaction&gt; getTransactionSender(Specialist specialist)
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>public interface TransactionManager&lt;E&gt; {
  public void confirmReception(UUID transactionId)
  public List&lt;Transaction&lt;E&gt;&gt; getPendingTransactions(Specialist specialist)
}</pre>
</div>
</div>
</li>
<li>
<p>Será el mismo Registry quien implementará la interfaz <code>TransactionManager&lt;CryptoTransaction&gt;</code>.</p>
</li>
<li>
<p>Además el Registry tendrá los siguientes métodos para los agentes:</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
EventWrapper es un contenedor de datos de información de eventos. Probablemente no hace falta.
</td>
</tr>
</table>
</div>
<div class="literalblock">
<div class="content">
<pre>// To manage events
// Used by the Monitor Agent
void saveNewEvent(String eventType, String eventSource) throws CantSaveEvent;
EventWrapper getNextPendingEvent() throws CantReadEvent;
void discardEvent(UUID eventId) throws CantReadEvent, CantSaveEvent;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>//To manage transactions</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>// User by the Monitor Agent
// Las coloca en (A,TBN)
void acknowledgeTransactions(List&lt;Transaction&lt;CryptoTransaction&gt;&gt; transactionList) CantAcknowledgeTransactionException;
// Retorna las que están en (A,TBN)
List&lt;Transaction&lt;CryptoTransaction&gt;&gt; getAcknowledgedTransactions() CantGetTransactionsException;
// Pasa una de (R,NAR)
void acquireResponsibility(Transaction&lt;CryptoTransaction&gt; transaction) CantAcquireResponsibility;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>// Used by Relay Agent
// Retorna las (R,NAR)
List&lt;Transaction&lt;CryptoTransaction&gt;&gt; getResponsibleTransactions() CantAccessTransactionsException;
// Pasa la transacción a TBN y le agrega el Specialist.
void setToNotify(UUID id, Specialist specialist)
// La lista de (R,TBN) o (R,SN)
List&lt;Transaction&lt;CryptoTransaction&gt;&gt; getResponsibleTransactionsPendingAction() CantAccessTransactionsException;
// Da los Specialist de las que están en TBN y SN
List&lt;Specialist&gt; getSpecialists() CantReadSpecialistsException;
// Pasa las que son TBN a SN
void setSendingNotified() CantSaveTransactionsException;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_opci_2_contrapropuesta_de_ezequiel">Opció 2: Contrapropuesta de Ezequiel</h5>
<div class="ulist">
<ul>
<li>
<p>Tras analizar el tema de concurrencia llegué a la conclusión de que puedo evitar pasar el Registry a otros módulos y además puedo resolver los temas de concurrencia que hablamos hoy.</p>
</li>
<li>
<p>La solución a los temas de concurrencia la hago abriendo la tabla que requiere usar cada método del registry como primer sentencia del método (cosa que igual tengo que hacer en la otra implementación). Esto da un objeto Database propio a cada thread dado que las variables serán locales y esas son exclusivas por thread, por lo que la concurrencia pasa a ser solucionada por el motor de base de datos según la conclusión que tuvimos hoy (ayer).</p>
</li>
<li>
<p>A mí esta solución me parece más simple, sería el pluginRoot el que implementa la interfaz TransactionSender como pensaba inicialmente.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Dejo a su elección la implementación que considere mejor (si agregar lo del transaction manager o dejar simplemente la intefaz transaction sender). Como dije, yo prefiero la segunda opción.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
En ambos casos hay que tratar lo que escribí <a href="#Transaction-Transference-Protocol-v2-NotaParaLuis">abajo</a>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_analizar">Analizar</h4>
<div class="ulist">
<ul>
<li>
<p>¿Se pueden fusionar el Monitor y el RelayAgent en un sólo thread?</p>
<div class="ulist">
<ul>
<li>
<p>Preferimos no hacerlo al menos para esta versión. En teoría podría hacerse.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Analizar si pude quitarse el parámetro Specialist al método <code>getPendingTransactions</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="Transaction-Transference-Protocol-v2-NotaParaLuis">Nota para Luis</h4>
<div class="paragraph">
<p>Tuve que mirar el código de la parte de base de datos. No sé si alguien más aparte de mí está trabajando con cosas multithread pero dejo un par de aclaraciones de lo que veo.
La versión corta es que hay que cambiar un par de lineas de un archivo del plugin de base de datos, la explicación del por qué la dejo acá abajo.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Si bien a nivel de SQL las cosas pueden tener locks y demás mecanismos de concurrencia, lo que manejamos desde otros plug-ins es una abstracción, por ende si alguna variable de clase (member) es usada por los métodos que implementan estas abstracciones entonces serán compartidas por los threads que usen un mismo objeto.<br></p>
</li>
<li>
<p>Si un método que es llamado por varios threads accede a una tabla (un objeto DatabaseTable), uno puede crear una instancia de DatabaseTable nueva en cada llamada del método para que estos no compartan variables de las abstracciones (acá la abstracción es el objeto DatabaseTable). Es decir hacer algo así:</p>
<div class="literalblock">
<div class="content">
<pre>public void metodoCompartido(){
   DatabaseTable t = this.database.getTable(Nombre_de_la_tabla);
   ...
   Manipulan la tabla
   ...
}</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Eso puede dar la impresión de resolver el tema, pero si uno presta atención se usa una variable de la clase para acceder a una nueva tabla (la variable referenciada como <code>this.database</code>)<br>
El código del método getTable de la clase Database está <a href="https://github.com/bitDubai/fermat-pip-android-addon-os-android-database-system-bitdubai/blob/master/src/main/java/com/bitdubai/android_fermat_pip_addon_layer_2_os_file_system/version_1/structure/AndroidDatabase.java#L116">aquí</a>, como vemos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>    /**
     * &lt;p&gt;Return a DatabaseTable definition
     *
     * @param tableName name database table using
     * @return DatabaseTable Object
     */
    @Override
    public DatabaseTable getTable(String tableName){

        databaseTable = new AndroidDatabaseTable(this.context,this.Database, tableName);

        return databaseTable;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>La variable databaseTable es un miembro de la clase, por lo que sería compartidas por distintos threads.<br>
Eso a mi entender trae problemas porque si dos threads llaman a métodos que requieren tablas distintas de la misma base de datos tendría trazas que hacen que el pedido de un thread pise al del otro (debido a esa asignación previa al return).<br>
Esto haría que necesite no sólo obtener la tabla dentro de un método compartido por varios threads sino que también hace que tenga que abrir la base de datos en el inicio de cada llamada a un método de ese estilo.<br>
Afortunadamente el método <code>openDatabase(UUID ownerId, String databaseName)</code> del DatabaseSystem no usa miembros de clase y sólo usa variables locales por lo que parece ser thread safe (por lo que el problema no escalaría otro nivel más). El código es <a href="https://github.com/bitDubai/fermat-pip-android-addon-os-android-database-system-bitdubai/blob/master/src/main/java/com/bitdubai/android_fermat_pip_addon_layer_2_os_file_system/version_1/structure/AndroidPluginDatabaseSystem.java#L28">este</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>    @Override
    public Database openDatabase(UUID ownerId, String databaseName) throws CantOpenDatabaseException, DatabaseNotFoundException {
        try{
            AndroidDatabase database;
            String hasDBName = hashDataBaseName(databaseName);
            database = new AndroidDatabase(this.Context, ownerId, hasDBName);
            database.openDatabase(hasDBName);

            return database;
        }
        catch (NoSuchAlgorithmException e)
        {
            throw new CantOpenDatabaseException();
        }

    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Más allá de eso, analicé el código problemático del AndroidDatabase (la clase que implementa la interfaz Database para Android) y en mi opinión cambiando el código de la implementación de la base de datos que dice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>    public DatabaseTable getTable(String tableName){

        databaseTable = new AndroidDatabaseTable(this.context,this.Database, tableName);

        return databaseTable;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>por simplemente</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public DatabaseTable getTable(String tableName){
    return new AndroidDatabaseTable(this.context,this.Database, tableName);
}</pre>
</div>
</div>
<div class="paragraph">
<p>se arregla la necesidad de que tenga que abrir la base de datos en cada método. La variable que se asigna en ese código es variable de clase (miembro), pero no es usada en ningún otro lado. Igual pediría que lo revise alguien que entiende mejor el plug-in (yo sólo navegué un par de clases).<br></p>
</div>
<div class="paragraph">
<p>Yo implementé los métodos abriendo la tabla para generar una copia exclusiva para cada thread, pero si mi razonamiento es correcto hay que corregir el código de la base de datos que menciono.<br></p>
</div>
<div class="paragraph">
<p>Si mi razonamiento es erroneo, me disculpo por el tiempo que pueda haber llevado leer mi análisis.</p>
</div>
<div class="paragraph">
<p>Luego vi que pasa algo similar con el método</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>    @Override
    public DatabaseTransaction newTransaction(){

        return databaseTransaction = new AndroidDatabaseTransaction();
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aquí la variable <code>databaseTransaction</code> se usa en otra parte, pero parece ser innecesaria también. Esa preferiría que también la revisen. Aunque en este caso no sé si sería probelmático (no revisé el código de las transacciones).</p>
</div>
<div class="paragraph">
<p>Por último intenté analizar el método <code>executeTransaction</code> de la clase AndroidDatabase, excede mis conocimientos saber si hay problemas allí. Se referencia a una variable que es miembro de la clase (es decir, una que no es variable local del método y por ende podría ser compartida por varios threads al invocarlo), pero esa variable es una referencia a una instancia de la clase SQLiteDatabase, con la cual no estoy familiarizado.</p>
</div>
</div>
<div class="sect3">
<h4 id="_consultar">Consultar</h4>
<div class="ulist">
<ul>
<li>
<p>Consultar a Rodrigo la longitud de un hash de una transacción crypto para almacenar en la base de datos del Regysty.</p>
</li>
<li>
<p>Consultar a Rodrigo la longitud de una dirección bitcoin de una transacción crypto para almacenar en la base de datos del Regysty.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_plug_ins_in_this_layer_9">Plug-ins in this layer</h4>

</div>
</div>
<div class="sect2">
<h3 id="_incoming_crypto">Incoming Crypto</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_17">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="FermatDMP-CryptoTransactionLayer-IncomingCrypto-Bitdubai-1">Incoming Crypto - Version 1</h5>
<div class="sect5">
<h6 id="_plug_in_description_6">Plug-in Description</h6>
<div class="paragraph">
<p>Crypto networks use transactions to send value (crypto currency) from a user to another. We will use the term <strong>crypto transaction</strong> to refer to this kind of transactions.<br>
We will use the term <strong>transaction</strong> to refer to the duty of updating balances of wallets and volts to reflect the new value that arrived from the crpto transaction.<br>
It is clear that every crypto transaction produce a transaction.<br></p>
</div>
<div class="paragraph">
<p>When new crypto transactions arrive to a wallet of the user logged in the device, one plug-in must update the corresponding wallet and crypto volt balances, i.e. apply the transaction.<br>
The plug-in that receive a crypto transaction is responsible of the associated transaction until it applies the said updates or it handles the transaction to another plug-in who knows how to manage it.<br>
The plug-ins that receive the crypto transaction (e.g. crypto networks and external wallets supported by the world layer) don&#8217;t know how to apply the transactions and neither who is responsible of applying them. The purpose of this plug-in is then, to take the responsibility of the transactions from the initial plug-ins, decide what kind of plug-in should handle them and notify them trough an event so he can transfer this more specific plug-ins the responsbility of applying them.<br></p>
</div>
<div class="paragraph">
<p>In other words, this plug-in works as a router. Its purpose is to listen to two events named IncomngCryptoReceivedEvent and IncomingCryptoReversedEvent from diferent sources.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The IncomingCryptoReceivedEvent event informs that new transactions of crypto currency arrived to some wallet of the user logged in the device.<br></p>
</li>
<li>
<p>The IncomingCryptoReversedEvent event informs that a transaction that has been notfied has been reversed.<br></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that an IncomingCryptoReceivedEvent and a IncomingCryptoReversedEvent may be associated to the same crypto transaction but they produce two transactons (one to apply the crypto transaction and one to take back the changes).<br>
The plug-in must listen to this events, take the transactions from the source and take the responsability of giving this transactions to specialized plug-ins who know how to handle them.<br></p>
</div>
<div class="paragraph">
<p>We need to implement a transaction transference protocol described in the <a href="#Fermat-DMP-CryptoTransactionLayer">crypto transaction layer</a>, and also a policy to inform the arrival of new transactions, so we will need to design a mechanism of syncronization to coordinate the system actions.<br></p>
</div>
</div>
<div class="sect5">
<h6 id="_notas_to_be_translated_edited_and_deleted">NOTAS (TO BE TRANSLATED, EDITED AND DELETED)</h6>
<div class="paragraph">
<p>Cuando llega el dinero en este sistema distribuido, los dispositivos pueden estar prendidos o no. Además no sabemos si primero llega la información de la transacción o el valor de la misma.
Cuando llega primero el valor, no queda claro de quién proviene ni qué tipo de usuario lo envió (device,intra,extra user). Por eso este módulo existe, escucha eventos de crypto que llega y su misión es tomar pocesión de la transacción y luego pasársela a uno de los módulos más especializados (incoming-crypto-device, incoming-crypto-i BTC, incoming-crypto-extra).</p>
</div>
<div class="paragraph">
<p>Crypto network, billeteras externas</p>
</div>
<div class="paragraph">
<p>El mósulo recibe el evento, averigua su fuente y comienza una especie de protocolo para hacerse cargo de la transacción y luego avisarle a quien le envió el evento que ya tomó la posta y ahora se encarga él.</p>
</div>
<div class="paragraph">
<p>Si llega 1 BTC a la crypto network, cuando llega ese bitcoin el módulo de la crypto network asume que es responsable de ese valor. Entonces emite un evento que avisa que llegó ese dinero hasta que alguien tome el control de la transacción.</p>
</div>
<div class="paragraph">
<p>El incoming crypto escucha el evento, toma el control de la transacción, avisa a la crypto network que ya la tiene y la crypto network deja de enviar el evento por dicha transacción.</p>
</div>
<div class="paragraph">
<p>Todas las confirmaciones se hacen cuando las cosas se grabaron persistentemente, no cuando las toman en memoria.</p>
</div>
<div class="paragraph">
<p>Cosas similares se hacen para averiguar de qué tipo de usuario viene la transacción para pasarle la pocesión a ese módulo.</p>
</div>
<div class="paragraph">
<p>Los transaction managers los deben implementar también los módulos que lanzan estos eventos que informan transacciones.</p>
</div>
<div class="paragraph">
<p>Cuando el módulo especializado en el tipo de usuario escucha el evento del incoming crypto y toma responsabilidad de la transacción. Luego aplica las acciones que sean necesarios para actualizar el estado de las billeteras y otros módulos para que reflejen la llegada de la transacción.<br>
Deben reflejarse los aspectos de información y valor. La información está en las wallets en general y el valor en la crypto volt (bóbeda)</p>
</div>
<div class="ulist">
<div class="title">Eventos</div>
<ul>
<li>
<p>Identify: se ve una transacción en la red pero sin confirmaciones</p>
</li>
<li>
<p>Received: la transacción obtiene la primer confirmación</p>
</li>
<li>
<p>ReceptionConfirmed: la transacción es totalmente confirmada (en bitcoin son 6 confirmaciones)</p>
</li>
<li>
<p>Reversed: La transacción fue revertida</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">IncommingCryptoRegister Table Fields</div>
<ul>
<li>
<p>Id: identificadr</p>
</li>
<li>
<p>AddressTo: Dirección de destino de la transacción</p>
</li>
<li>
<p>CryptoCurrency: Enum de la crypto</p>
</li>
<li>
<p>CryptoAmount: Cantidad de crypto</p>
</li>
<li>
<p>Source: Dirección de origen de la transacción</p>
</li>
<li>
<p>Destination: Debe ser origen en realidad, intra/device/extra user para saber a quién avisar sobre la transacción</p>
</li>
<li>
<p>CryptoStatus: Estado de la transacción en la red crypto</p>
<div class="ulist">
<ul>
<li>
<p>IDENTiFY: Se ve la transacción en la red sin confirmaciones (no actuar)</p>
</li>
<li>
<p>RECEIVED: Ve la transacción con una confirmación (hacer las actualizaciones)</p>
</li>
<li>
<p>CONFIRMED: Ve la sexta confirmación</p>
</li>
<li>
<p>REVERSED: Se revierte la transacción, es raro pero puede pasar (considerar como revertir las cosas)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Status: Ciclo de vida del protocolo</p>
<div class="ulist">
<ul>
<li>
<p>COLOCAR LOS ENUMS</p>
</li>
</ul>
</div>
</li>
<li>
<p>Timestamp: marca de tiempo</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">IncomingCryptoEventsRecorded Table Fields</div>
<ul>
<li>
<p>Id</p>
</li>
<li>
<p>Event</p>
</li>
<li>
<p>Source</p>
</li>
<li>
<p>Status</p>
</li>
<li>
<p>Timestamp</p>
</li>
</ul>
</div>
<div class="sect6">
<h7 id="_agentes">AGENTES</h7>
<div class="paragraph">
<p>Monitor: Procesa los eventos que registra en recorderService<br>
Se despierta periódicamente y mira si hay evento que le interese.<br>
Si hay eventos sobre los que deba actuar (¿con next pending event?, un confirmed por ejemplo) el agente procede a tomar la poseción de la transacción.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La clase root inicializa los agentes y el eventRecorderService.</p>
</li>
<li>
<p>El monitor se despierta, pide al registry el siguiente evento a tratar.</p>
<div class="ulist">
<ul>
<li>
<p>Si tiene algo, busca el source del evento, se comunica por la interfaz del source para pedirle el registo de las transacciones y hace lo que corresponda. Al parece lo que corresponde es tomar la información de la transacción y avisarle al source que la capa de transacciones se va a hacer cargo desde ahora.</p>
</li>
<li>
<p>Si no tiene eventos, se duerme de nuevo.</p>
</li>
</ul>
</div>
</li>
<li>
<p>El relay, le pide al registry las transacciones de las que la capa es responsable (las que recibe el monitor). Consulta si viene de un intra, extra o device user y manda un evento adecuado para que lo procece el módulo correspondiente (incoming crypto intra, incoming crypto extra, outgoing crypto intra, etc.).</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_outgoing_crypto">Outgoing Crypto</h3>
<div class="sect3">
<h4 id="_versions_developed_by_bitdubai_18">Versions developed by BitDubai</h4>
<div class="sect4">
<h5 id="_version_1_15">Version 1</h5>
<div class="sect5">
<h6 id="_plug_in_description_7">Plug-in Description</h6>
<div class="paragraph">
<p>Cuando el usuario hace un envío de dinero a través de la bitcoin wallet, se invoca a este plug-in para que ejecute el envío pedido y para que actualice los balances de la wallet.<br>
Cuando se invoca a este módulo conceptualmente se crea una transacción a ejecutar, la cuál debe mantener consistente tanto el estado del balance de la wallet como el estado de los fondos en la crypto red. <br>
El balance es llevado por el plug-in BitCoinWalletBasicWallet mientras que el envío que se hace en la red es llevado por el plug-in CryptoVault de la red bitcoin.<br></p>
</div>
<div class="paragraph">
<p>Cuando se desea hacer un pago a una wallet se le pide a este plug-in un TransactionManager. Este objeto implementa un método de envío de bitcoins que requiere como parámetros el ID de la wallet que se usa para enviar el dinero, la dirección de destino y el monto a enviar.<br></p>
</div>
<div class="paragraph">
<p>El TransactionManager debe buscar a la wallet indicada, actualizar su balance y enviar el monto por la red bitcoin.<br>
Si bien esto parece simple, debemos considerar varias posibles fallas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Que el sistema se caiga en cualquier punto de las actualizaciones.</p>
</li>
<li>
<p>Que no se pueda enviar la transacción bitcoin por la red por cuestiones diversas (imposibilidad de conectarse a la red, dirección ingresada con formato erroneo).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Cuando se entrega un transaction manager para una wallet se debería abrir una base de datos que tiene el registro de las transacciones creadas con un estado asociado.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>NEW (NEW): Cuando el usuario ejecuta el envío del pago</p>
</li>
<li>
<p>PERSISTED_IN_WALLET (PIW): Cuando hemos persistido exitosamente el cambio del balance en la bitcoin wallet</p>
</li>
<li>
<p>SENT_TO_CRYPTO_VOULT (STCV): Cuando se envió correctamente por la red bitcoin.</p>
</li>
<li>
<p>SUCCESSFUL_SENT (SS): Cuando se registró el envío en la red.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A futuro:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>REVERSED (REV): Cuando la vault avisa que se reversó la transacción enviada (la vault se encarga de reenviarla)</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fermat_dap_system_layers">Fermat-DAP System Layers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(SECCION PARA SER COMPLETADA POR EL EQUIPO DE DAP+ NOTA DE FERMAT-BOOK-MANAGER (<a href="mailto:book@fermat.org">book@fermat.org</a>) 27-9-2015)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fermat_dap_actor">FERMAT-DAP /actor</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="actor-asset-issuer-BitDubai-V1">Version 1</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_plug_in_description_8">Plug-in Description</h3>

</div>
<div class="sect2">
<h3 id="_plug_in_structure_2">Plug-in Structure</h3>

</div>
<div class="sect2">
<h3 id="_events_2">Events</h3>

</div>
<div class="sect2">
<h3 id="_implementation_details_2">Implementation Details</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="actor-asset-user-BitDubai-V1">Version 1</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_plug_in_description_9">Plug-in Description</h3>

</div>
<div class="sect2">
<h3 id="_plug_in_structure_3">Plug-in Structure</h3>

</div>
<div class="sect2">
<h3 id="_events_3">Events</h3>

</div>
<div class="sect2">
<h3 id="_implementation_details_3">Implementation Details</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="wallet-module-asset-user-BitDubai-V1">Version 1</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_plug_in_description_10">Plug-in Description</h3>

</div>
<div class="sect2">
<h3 id="_plug_in_structure_4">Plug-in Structure</h3>

</div>
<div class="sect2">
<h3 id="_events_4">Events</h3>

</div>
<div class="sect2">
<h3 id="_implementation_details_4">Implementation Details</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="identityPublicKey-asset-issuer-BitDubai-V1">Version 1</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Esta Plugin Asset Factory de naturaleza CRUD, su función principal es la, modificación, y listado del Asset en su etapa de fabricación, para que pueda ser consultados en toda sus etapas,
y poder actualizar sus propiedades, siempre y cuando este en "state" <em>Draft</em>.</p>
</div>
<div class="sect2">
<h3 id="_plug_in_description_11">Plug-in Description</h3>
<div class="paragraph">
<p>Este pluggin pedira las siguiente propiedades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identity Asset Issuer: Identity del Actor AssetIssuer</p>
</li>
<li>
<p>String name: nombre del Asset definido por el issuer.</p>
</li>
<li>
<p>String description: descripción del asset definido por el issuer.</p>
</li>
<li>
<p>List&lt;Resource&gt;: lista de recursos posibles del asset, como por ejemplo imágenes, videos, etc.</p>
</li>
<li>
<p>String GenesisTransaction: hash de la transacciín bitcoin donde el asset está incluido.</p>
</li>
<li>
<p>Address GenesisAddress: dirección Genesis generada por la Asset Vault</p>
</li>
<li>
<p>Cantidad de Assets que se están creando (DigitalAsset.quantity)</p>
</li>
<li>
<p>Valor de cada Asset. (DigitalAsset.unitValue)</p>
</li>
<li>
<p>Valor del Fee de cada transacción. (DigitalAsset.transactionFee).</p>
</li>
<li>
<p>long GenesisAmount: valor crypto del digital asset en Satoshis.
<strong>DigitalAsset.quantity * DigitalAsset.unitValue + ( DigitalAsset.transactionFee * DigitalAsset.quantity)</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El Issuer debe determinar el calculo del transactionFee, llamando un metodo de la cryptoVault getEstimatedFeeValue, y tambien chequear que hayan fondos disponibles para cubrir el GenesisAmount.</p>
</div>
<div class="paragraph">
<p>Una vez que todas las validaciones anteriores esten correctas debemos de comenzar el envio a la capa transaccional con el metodo IssueAsset(DigitalAsset digitalAsset) y setear el "state" a <em>PendingFinal</em>,
y luego cuando tengamos el GenesisTransaction y GenesisAddress, procedemos actualizarlo en el Digital Asset del Factory y el "state" a <em>Final</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_plug_in_structure_5">Plug-in Structure</h3>

</div>
<div class="sect2">
<h3 id="_events_5">Events</h3>

</div>
<div class="sect2">
<h3 id="_implementation_details_5">Implementation Details</h3>

</div>
<div class="sect2">
<h3 id="best-practices">Best Practices</h3>
<div class="paragraph">
<p><a href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/">https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/</a></p>
</div>
<div class="paragraph">
<p><a href="http://blog.jooq.org/2013/08/20/10-subtle-best-practices-when-coding-java/">http://blog.jooq.org/2013/08/20/10-subtle-best-practices-when-coding-java/</a></p>
</div>
<div class="paragraph">
<p>Definamos lo todo lo conveniente.</p>
</div>
</div>
<div class="sect2">
<h3 id="_consideraciones_para_dap">Consideraciones para DAP</h3>
<div class="ulist">
<ul>
<li>
<p>Crear una DAPException para poder manejar todo tipo de Exception que se presente</p>
</li>
<li>
<p>Validar todos los SET y GET con THROWS para asegurar que tengan valores y no se generen
Excepciones desencadenadas de NULL</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_uso_de_getters">Uso de "getters"</h4>
<div class="paragraph">
<p>Todos los métodos getters deben usar en la Digital Asset Platform deben seguir el siguiente formato:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="java language-java">public void getSomething() throws ObjectNotSetException {

    ....
    if(returningObject==null){
        throw new ObjectNotSetException("The object to get is null", "getSomething() method in DAPClass", "Some description");
    }

    return returningObject

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>El objetivo de esta técnica es evitar que los métodos getters devuelvan null, para ello se debe realizar una verificación previa antes de obtener algún objeto.</p>
</div>
<div class="paragraph">
<p>En el caso de implementar un método get proveniente de una interfaz que no posea throws ObjectNotSetException, se recomienda usar el report manager para que quede registrada el intento de obtener un objeto que está null, por ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="java language-java">@Override
public void getSomething(){
    ...
    try{
        if(returningObject==null){
            throw new ObjectNotSetException("The object to get is null")
        }
    } catch(ObjectNotSetException exception) {
        this.errorManager.reportUnexpectedPluginException(Plugins.BITDUBAI_DAP_PLUGIN, UnexpectedPluginExceptionSeverity.DISABLES_SOME_FUNCTIONALITY_WITHIN_THIS_PLUGIN, exception);
    }
}


== Refactor Pendientes por hacer:

* Cambiar todos UUID a string las propiedades de las wallet, skin, language, ya que deberan de usar la publickey asociada.

:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 2
[[digital-asset-transaction-asset-issuing-BitDubai-V1]]
= Version 1

Este plugin, de naturaleza transaccional, tiene por objetivo recopilar toda la información necesaria para la emisión de un Digital Asset.
Esta información, no solo contendrá el detalle de la transacción cripto (Genesis transaction) asociada al asset,
deberá incluir la información multimedia que sirva para la construcción de la UI del Asset en el dispositivo, asi como el contrato de uso del mismo.

El plugin Asset Issuing será el encargado de la creación de los Assets, incluyendo metadata y crypto monto, que posteriormente serán enviados a los posibles destinatarios de los Digital Assets. Este plugin
deberá solicitar la genesis transaction, la cual se define como la transacción origen de los crypto montos a ser transferidos junto al asset, así mismo, debe solicitar
la genesis address, la cual se define como la dirección que emitió el Asset. Una vez obtenida la información antes mencionada, este plugin debe crear las transacciones que
permitan la transferencia de los Assets a los destinatarios. Este plugin debe ser responsable de cada uno de los Assets generados hasta que todos hayan sido entregados a los
destinatarios. Este plugin debe tener la capacidad de monitorear que Asset ha sido entregado y registrarlo, para su posterior consumo. Si un asset no hasido registrado como entregado por este plugin, ese Asset no debería ser consumido por el beneficiario.
Estos Assets pueden ser enviados a cualquier tipo de wallet, es decir, debe ser transparente para este plugin los destinatarios de los assets, la metadata que se entrega a
 este plugin debe incluir la información que permita discriminar a que tipo de wallet/destinatario va dirigido el Asset, este proceso de filtrado podría tomarse de las wallets
 instaladas actualmente, este plugin debe recibir de una capa superior el criterio de selección de los destinatarios, de tal forma que este pueda crear la transación que permita
 enviar el asset al destinatario.
Los Assets que no se hayan enviado deben permanecer en el dispositivo emisor (Asset Distribution) hasta que el beneficiario haya autorizado la instalación/descarga del digital asset
a su dispositivo. Al momento de instalación del Asset en el dispositivo destino es que se debe realizar la trasferencia del crypto monto al dispositivo destino.
Los crypto montos del emisor asociados a cada assets deben estar reservados en el dispositivo emisor hasta que sean transferidos a los beneficiarios. Estos montos no deben
cambiar una vez reservados.

== Plug-in Description

El objeto DigitalAsset de la plataforma, contará con las siguientes propiedades:

 * Identity Asset Issuer: Identity del Actor AssetIssuer
 * String name: nombre del Asset definido por el issuer.
 * String description: descripción del asset definido por el issuer.
 * List&lt;Resource&gt;: lista de recursos posibles del asset, como por ejemplo imágenes, videos, etc.
 * String GenesisTransaction: hash de la transacciín bitcoin donde el asset está incluido.
 * Address GenesisAddress: dirección Genesis generada por la Asset Vault
 * long GenesisAmount: valor crypto del digital asset en Satoshis.

 Digital Asset Contract (DAC)

Como contrato básico para el Digital Asset para poder cerrar el ciclo en el desarrollo inicial de la plataforma,
especificaremos que:

 * Redimible.
 * ExpirationDate: fecha de expiración que puede ser nunca.
 * Transferible.

La emisión de un Digital Asset va a tener un enum con los siguientes estados:

* Draft: cuando el issuer está completando los datos básicos del asset y del contrato.
* PendingFinal: cuando el issuer solicita que se arme la transacción bitcoin y se cierre el asset.
* Final: cuando se generó el hash del DA y el Asset ya no se puede modificar.

La construcción de una Digital Asset Transaction va a tener los siguientes estados:

* Blank: estado inicial, en el cual no se ha llevado ningún proceso transaccional.
* RequestingGenesisAddress: solicitando una dirección a la cryptoVault.
* GenesisAddressObtained: la genesis address se obtuvo de la Crypto Vault.
* SendingBitcoins: estado en el cual se solicita la transferencia de fondos a la wallet Issuer.
* BitcoinsSent: La transferencia de fondos se realizó correctamente.
* ToRedeem: estado en el cual se espera el canje del Asset.
* CheckingAsset: estado en el cual se verifica la transacción asociada al Asset.
* ReturningBitcoins: estado en el cual la genesis amount se comienza a transferir a la Wallet emisora.
* BitcoinsReturned: estado en el cual se ha completado la transferencia a la Wallet Emisora.
* Redeemed: estado en el cual el Asset se considera redimido.


Al iniciar el plugin este instancia al objeto DigitalAssetCryptoTransactionFactory, el cual será el encargado de tomar el Digital Asset creado por AssetIssuingTransactionPluginRoot con los datos provenientes de la UI a través del AssetIssuerModule.
DigitalAssetCryptoTransactionFactory (DACTF) usará una instancia del CryptoVaultManager para crear la genesis transaction, la cual quedará registrada en el CryptoAddressBook por medio de CryptoAddressBookManager, que se va a asociar al objeto Digital Asset y así crear un nuevo DigitalAssetMetadata, este último objeto debe generase al concluir
el proceso de creación del digital Asset, ya que este es quien ajustaría el estado a _final_, una vez que se encuentra en este estado ya no se debe modificar ninguna característica del Digital Asset.

=== Pasos detallados:

Diagrama de Flujo en Prezi: http://prezi.com/fy3cag7olwbz/?utm_campaign=share&amp;utm_medium=copy&amp;rc=ex0share

1) La AssetIssuer subApp, a través de un wizard solicitará los datos básicos necesarios para la creación del asset. En el mismo se
 realizarán distintas especificaciones del asset y el contrato inicial.



 La Asset Factory debe mostrar al usuario el monto final de la transacción bitcoin (GenesisAmount) para su aprobación mediante
 el uso de los siguientes campos:
* Cantidad de Assets que se están creando (DigitalAsset.quantity)
* Valor de cada Asset. (DigitalAsset.unitValue)
* Valor del Fee de cada transacción. (DigitalAsset.transactionFee).

El valor del GenesisAmount se calculará de la siguiente forma:

 *DigitalAsset.quantity * DigitalAsset.unitValue + ( DigitalAsset.transactionFee * DigitalAsset.quantity)*

El DigitalAsset.transactionFee es un valor que calculará la cryptoVault a través del método getEstimatedFeeValue.

La Issuer subApp no permitirá iniciar el proceso de issuing del Asset si no dispone los fondos disponibles para cubrir el GenesisAmount.

Todos los procesos de generación y edicion del Asset serán persistidos en el plugin Middleware Asset Factory. Al momento de finalizar con la
edición y dar comienzo a la transacción de Asset Issuing, el mismo ya dejará de estar editable en la sub App del issuer.

La transacción de Asset Issuing se dará inicio a través del método IssueAsset(DigitalAsset digitalAsset).

1) El primer paso es asegurarse que el DigitalAsset (DA) está completo en todos sus campos y contrato. Las únicas propiedades que no deben estar completas son GenesisTransaction y
GenesisAddress.

2) Al estar todo completado para emitir el Asset, se persiste el DA (en archivo) y se actualiza el TransactionStatus a FormingGenesis.
El asset guardado en la Asset Factory pasa a estado final y no puede volver a ser modificado en la subApp Issuer.

3) Se llama al método generateEmptyTransactionHash() de la CryptoVault que devolverá un String con el Hash de la genesis Transaction. El especialista de la transacción
para a ser en este momento la CryptoVault hasta que devuelve el valor esperado. Se actualiza este valor en el DA y se persisten los cambios.

4) Se llama al método requestGenesisAddress de la AssetWallet y se persistirá este valor en la GenesisAddress. Esta solicitud de dirección
debe ser registrada en el CryptoAddressBook a través del método registerCryptoAddress.

5) Se creará el objeto DigitalAssetMetadata y se generará el hash del DA con el método getDigitalAssetHash. La transacción pasaría a estar en estado PendingSubmitCryptoNetwork.

6) Se enviará la transacción a través de la cryptoVault utilizando el metodo send de la CryptoWallet y se pasan los siguientes valores:

* transactionId: el obtenido en el paso 3.
* addressTo: la obtenida en el paso 4.
* OP_RETURN: el hash del objeto DigitalAssetMetadata (DigitalAssetMetadata.getDigitalAssetHash())
* Amount: el valor calculado en el punto 1.

La transacción pasa a estado PendingReceiveCryptoNetwork

7) Al momento de ingresar la transacción bitcoin a través de la crypto Network, la transacción pasa a estado PendingConfirmCryptoNetwork y ejecutamos un crédito en el book
balance de la Asset Wallet. En este momento, el DigitalAssetMetadata queda persistido en la Asset Wallet. La transacción debe escuchar los eventos
del incoming crypto.



8) Al confirmarse la transacción en la cryptoNetwork la transacción pasa a estado PendingConfirmationIssuerWallet y se genera el crédito  en el Available balance en la
Issuer Wallet.

9) La issuerWallet genera un crédito en el available balance de la wallet y confirma que toma posesión del DA.

10) La transacción finaliza y actualiza a Finalized.

== Plug-in Structure

== Events

== Implementation Details


:leveloffset: 2
[[digital-asset-transaction-incoming-issuer-BitDubai-V1]]
= Version 1
    Por definir.
= Plug-in Description

= Pasos detallados

Diagrama de flujo en Prezi: http://prezi.com/_mbtb0pa22c3/?utm_campaign=share&amp;utm_medium=copy&amp;rc=ex0share

.Escenario:


Nos encontramos con balance positivo en la Asset Wallet de al menos un asset disponible. Esto significa que disponemos del objeto _DigitalAssetMetadata_ persistido
en la wallet y bitcoins en la Asset Vault (Ver &lt;&lt;digital-asset-transaction-asset-issuing-BitDubai-V1,Asset Issuing Transaction&gt;&gt; ) suficientes para transferir el asset la cantidad de veces que sea necesaria.

Al tener instalada en el dispositivo la Issuer Wallet, el &lt;&lt;actor-asset-issuer-BitDubai-V1, Actor NetworkService Issuer&gt;&gt; ha comenzado a solicitar al Communication Server
la lista de Asset Users disponibles y persiste esta información en su base de datos. Entre otros datos, se guarda la dirección Bitcoin de cada user.

Es decir, tenemos balance positivo y una lista de usuarios a quienes enviar el asset.

En la reference Wallet del Asset Issuer se ha seleccionado enviar el asset (o los assets) a ciertos usuarios, lo cual inicia la transacción Asset Distribution
con los siguientes pasos:

1) Se llama al método distributeAsset (String assetPublicKey, List&lt;AssetUser&gt; assetUsers) que inicia la transacción recibiendo el id del asset a distribuir y
la lista de usuarios a distribuir. El estado de la transacción se actualiza a PendingVerify

2) Se debe verificar que el Asset no ha sido modificado externamente y que sigue siendo válido comparando el Hash del Asset con el Hash guardado en la Genesis Transaction.
Para ello, se obtiene el hash de la genesis transaction invocando al método getAssetHash(transactionId genesisTransaction) de la AssetVault.

Si la comparación entre el _DigitalAssetMetadata_ es igual a la obtenida por la Asset Vault, entonces el asset es válido sigue siendo válido.

3) Debemos verificar que seguimos disponiendo fondos suficientes en la Asset Vault para transferir los assets invocando al método _getAssetVaultBalance_ de la Asset Vault
 y verificando que disponemos de un balance superior al GenesisAmount del DA.

TIP: En esta etapa, el asset es válido para ser transferido y la transacción pasa a estado VerifyCompleted.

4) Lo siguiente ocurre por cada AssetUser a quien se transfiera. El objeto _assetUser_ va a tener la propiedad _CryptoAddress_ con la dirección bitcoin propia.

IMPORTANT: La AssetDistribution transaction debe mantener un registro por cada transacción de envío a Asset Users. La transaction macro de envío de/l asset/s
se descompone en tantas transacciones como usuarios a enviar existan.

.*En el dispositivo del Asset Issuer*

A través del Asset Transmission NetworkService, va a transmitir el AssetMetadata especificando al AssetUser llamando al método:
[source, java]
UUID distributeAssetToAssetUser(DigitalAssetMetadata, AssetUser);

Esta llamada será en forma asincrónica y su valor de retorno será un _DistributionId_ para persistir esta información y aguardar a que obtengamos el ok desde el Asset User networkService.

.*En el dispositivo del usuario*

El ActorNetworkService Asset User recibe el mensaje con el _DigitalAssetMetadata_ para validarlo y ejecuta lo siguiente:

* El UUID generado por _distributeAssetToAssetUser_ será persistido localmente para mantener un registro del ID de transacción y poder informar
luego el resultado.

Validación de _DigitalAssetMetadata_

* Verifica que el Asset es válido buscando en la blockChain la GenesisTransaction y obteniendo el hash del DigitalAsset. Compara el hash
obtenido con el generado por el _DigitalAssetMetadata_.getDigitalAssetHash. Si los valores son iguales el DA es válido.
* Verifica que el contrato del Digital Asset cumple con las propiedades. Es decir,
[source, java]
DigitalAssetContract.getContractProperty(DigitalAssetContractPropertiesConstants.EXPIRATION_DATE)

está dentro de la fecha válida.

* Infoma a través del NetworkService AssetUser que el AssetMetadata es válido informado el status completed del _DistributionId_ pasado originalmente.
En caso de error o que el asset no es válido o no cumple el contrato, se informa igualmente para cerrar esta transacción.

* De ser aceptado, el _DigitalAssetMetadata_ es persistido en la UserWallet sin actualizar aún balance ya que es medio asset.

* Informa a través del Asset User NetworkService pasando el _DistributionId_ y el status de ok para informar fin del proceso.

.*En el dispositivo del Asset Issuer*

El network Service del AssetUser retorna mensaje de OK o fallido para el _DistributionId_ generado y ocurre lo siguiente:

* Si no se aceptó el _DigitalAssetMetadata_, esta transacción se marca fallida y se cierra.
* Si se aceptó el _DigitalAssetMetadata_ entonces lo siguiente ocurre:
** Se envían los Bitcoins a través de un método de la AssetVault llamando al método:
[source, java]
sendAssetBitcoins (long amount, CryptoAddress sendTo, String AssetPublicKey)

 El *Amount* es la cantidad de satoshis del Asset que se obtiene de la propiedad DigitalAsset.getUnitValue()

 El *sentTo* es la dirección del AssetUser que la obtuvimos al inicio a través del ActorNetworkService Asset Issuer.

 El *AssetPublicKey* es el Id del asset que se obtiene de DigitalAsset.getPublicKey().

Esto genera una nueva transacción en la AssetVault que colocará el PublicKey del asset dentro de la transacción (*Output OP_RETURN*) y la enviará al usuario.

** Se genera un dèbito en la Issuer Wallet que indica que el Asset ha sido enviado tanto en su metadata como los bitcoins.

** Cuando luego la transacción bitcoin sea confirmada en la red por un bloque, se actualizará el balance available.

.*En el dispositivo del usuario*
* El Agent IncomingCrypto detectará el ingreso de los bitcoins y como la direccion a la que llegan está registrada a través del Address Book
se informará un evento que la Asset User Wallet escucha.
* La Asset User Wallet obtendrá de la transacción bitcoin que llegó la publicKey del asset buscando el output del tipo OP_RETURN para machearlo con la _DigitalAssetMetadata_ que
ya tiene guardada del paso anterior y actualizará el book balance.
* Cuando esta transacción bitcoin se confirme, actualizará el available balance de la wallet.


Si la conexión con el AssetUser no estaba abierta, entonces esta transmisión será marcada como fallida y se tendrá que reintentar más adelante.
Una propiedad en la Issuer Reference Wallet  definirá estos parámetros de retry.

Si el _DigitalAssetMetadata_ no fue aceptado, esta transmisión será marcada como erronea y no se volverá a reintentar.




== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 2
[[digital-asset-transaction-asset-redemption-BitDubai-V1]]
= Version 1

== Plug-in Description

Transaction Flow on Prezi: https://prezi.com/jwnuv7i13mnb/dap-asset-redemption/

.Escenario:

Nos encontramos en el dispositivo del usuario con al menos un asset disponible en su Asset User Wallet y los fondos necesarios en su Asset Vault
para al menos pagar el fee de una transacción.

El asset se encuentra confirmado y el Asset está disponible en el available Balance.

En la Asset user Reference Wallet el usuario tiene disponibles algunos Redeem Point obtenidos automáticamente por el Redeem Point Network Service.
El usuario selecciona el que tiene más cerca y se dirige a ese Redeem Point.

El redeem point seleccionado, tiene direcciones bitcoin generadas en forma independiente, a partir de una extended key enviada por el issuer.

Para redimir el asset en ese Reedem Point especifico el usuario pulsa la opcion Redeem habiendo seleccionado el Redeem Point correspondiente.

La transacción Asset Redemption ejecuta los siguientes pasos:

Se repiten los mismos pasos de la transacción Asset Distribution, con la diferencia que el asset se envía a un redeem point pero básicamente.

1) Verifica que el contrato del Asset permite que sea redimible. Luego valida que el Asset a enviar sigue siendo válido y no fue modificado.

2) Envía la metadata al Redeem Point para que haga las validaciones correspondientes del contrato.

3) Si es aceptado, hace el envío de bitcoins y genera el débito en la User Wallet.

4) El redeem point recibe los bitcoins con el asset publicKey en el output y marca genera el crédito en la Redeem Point wallet.

5) En el Asset Issuer se reciben también los bitcoins y se tiene registrada que la dirección a la que fueron enviados a que rama del árbol HD corresponden.
Con esta información, actualiza la estadística de la redimición de assets en la Issuer SubAp. Los bitcoins ingresados son enviados en una nueva transacción a la crypto Vault
ya que no pertenecen a ningún asset.

== Plug-in Structure

== Events

== Implementation Details


:leveloffset: 1
[line-through]#[[flujo-general-BitDubai-V1]]

= Flujo General de la Plataform DAP

= Flujo Desarrollo

El flujo de desarrollo del Asset describe lo necesario para generar un Digital Asset.

  Objeto Digital Asset (DA)

El objeto DigitalAsset de la plataforma, contará con las siguientes propiedades:

 * Identity Asset Issuer: Identity del Actor AssetIssuer
 * String name: nombre del Asset definido por el issuer.
 * String description: descripción del asset definido por el issuer.
 * List&lt;Resource&gt;: lista de recursos posibles del asset, como por ejemplo imágenes, videos, etc.
 * String GenesisTransaction: hash de la transacciín bitcoin donde el asset está incluido.
 * Address GenesisAddress: dirección Genesis generada por la Asset Vault
 * long GenesisAmount: valor crypto del digital asset en Satoshis.

 Digital Asset Contract (DAC)

Como contrato básico para el Digital Asset para poder cerrar el ciclo en el desarrollo inicial de la plataforma,
especificaremos que:

 * Redimible
 * ExpirationDate: fecha de expiración que puede ser nunca.
 * Transferible _(es bueno plantearlo desde la versión inicial para poder establecer a los responsables del proceso de traspaso de propiedad del Digital Asset)_

La emisión de un Digital Asset va a tener un enum con los siguientes estados:

* Draft: cuando el issuer está completando los datos básicos del asset y del contrato.
* PendingFinal: cuando el issuer solicita que se arme la transacción bitcoin y se cierre el asset.
* Final: cuando se generó el hash del DA y el Asset ya no se puede modificar.

== Assset Issuing

Una vez completadas estas propiedades por parte del Issuer, la Asset Issuer subApp, inicia una Digital Asset Transaction de Asset Issuing en la que lo siguiente ocurre:

* Se reciben la información multimedia y las características de la transacción del Digital Asset.
* Se solicita a la Crypto Vault la creación de una transaction bitcoin a través del Outoing Intra user. Este hash se define como la GenesisTransaction
en el Digital Asset.
* Se solicita a la Asset Vault una dirección bitcoin que será la GenesisAddress. Esta dirección solicitada queda registrada en el Address Book como solicitada por el Issue Actor,
la plataforma DAP y la vault de donde sale la dirección.
* Se completa la crypto transacción especificando el GenesisAmount.
* Se ejecuta un hash del Digital Asset y el mismo se coloca en el OP_RETURN de la crypto transacción.
* Se commitea la transacción y la misma es publicada a la red de bitcoin a través de la Crypto Network.
* Se asocia la metadata a la genesis transaction.
* El Digital Asset es considerado creado.
* El Digital Asset se considera available cuando la transacción bitcoin es detectada como entrante por el Incoming Crypto. _no entiendo este paso_
* Todos los Digital Assets generados deben ser transferidos al plugin AssetDistribution, este plugin se encargará de realizar la transferencia.

 Detalles de Modulos:

 * Asset Issuer (Module)
 Registrara toda la logica intermedia, originado de la (Sub App Module), que sera expuestas para la Asset Issuet (sub app)

 * Asset Issuer (Sub App Module)
 Registrara toda la logica de negocio que seran expuestas para la Asset Issuet (module)

 * Asset User (Module)
   Registrara toda la logica intermedia, originado de la (Sub App Module), que sera expuestas para la Asset User (sub app)

 * Asset User (Sub App Module)
   Registrara toda la logica de negocio que seran expuestas para la Asset User (module)

 * Redeem Point (Module)
   Registrara toda la logica intermedia, originado de la (Sub App Module), que sera expuestas para la Redeem Point (sub app)

 * Redeem Point (Sub App Module)
   Registrara toda la logica de negocio que seran expuestas para la Redeem Point (module)
* (Manuel completar más info de la transacción) *

Realizadas estas operaciones, y al momento de recibir el GenesisAmount en la Asset Vault, las operaciones de crédito dentro de la
Asset Wallet deben ocurrir.


 * *Asset Issuer Wallet (wallet)*

Realizara una transaccion contable al balance (asset issuet wallet), debitando la cantidad de Asset originado en su creacion, en el momento en que
el Issuer envie un Asset a un User, este le sea acreditado dicho al (asset issuet wallet) y debitado a la (asset user wallet), de esta forma el Issuer podria determinar el balance total enviado y disponible en su Book Address,
todo esta operacion debe ser originado mediante una transaccion de la capa transaction.

* *Asset User Wallet (wallet)*

Este proceso realizara una transaccion contable a la (asset user wallet), debitando el disponible de asset, y acreditando cuando sea redimido el asset,todo esta operacion debe ser originado mediante una transaccion
de la capa transaction.

* *Redeem Point Wallet (wallet)*

Este proceso determina el intercambio de la wallet Asset User donde mediante un metodo donde se pase las direcciones correspondiente se realizara una transaccion contable a la Asset del User, disminuyendo la cantidad de la wallet Asset User,
y acreditando o retornando dicho asset a la Asset Issuer en punto Reddem Point o en alguna wallet que determine la Redemcion.
Aclarar que pasa con este Asset si se puede volver a enviar.
Una vez verificada la genesis transaction por parte del Redeem Point, se debe notificar al plugin Outgoing Issuer que debe realizar la transferencia del monto crypto asociado
a la genesis transaction hacía el dispositivo que va a recibir el digital asset para su "redemción". Una vez que se produzca la transferencia del monto del Digital Asset
el dispositivo del beneficiero del asset debe proceder a registrar el consumo del mencionado Asset y proceder a su inhabilitación (¿?) del dispositivo y registrarlo como consumido.


El proceso de canje de un Asset por un servicio (Redeem Point) va a tener un enum, en el dispositivo del beneficierio, con los siguientes estados:
 * ToRedeem: cuando la Asset Wallet comienza el proceso de canje del DA.
 * Checking: cuando el DA ha sido enviado al Redeem point para su verificación.
 * Checked: cuando el Redeem Point ha revisado el DA.
 * Acepted: cuando el RP ha validado correctamente el contrato y la transacción del DA.
 * NotAcepted: cuando el RP ha validado la transacción del DA pero no el contrato del mismo.
 * NotRedeemable: cuando el ha validado el contrato del DA pero no la transacción del mismo.
 * Rejected: cuando el RP no ha validado la trasacción del DA ni el contrato del mismo.

 En el caso del dispositivo Redeem Point, el proceso de canje de un Digital Asset incluye los siguientes estados, definidos en un enum:
 * Incoming: cuando se recibe la notificación de un Asset entrante.
 * ToCheck: cuando el DA se ha recibido en el RP.
 * Checking: cuando el RP esté verificando la información provista por el DA.
 * Checked: cuando el Redeem Point ha revisado el DA.
 * Acepted: cuando el RP ha validado correctamente el contrato y la transacción del DA.
 * NotAcepted: cuando el RP ha validado la transacción del DA pero no el contrato del mismo.
 * NotRedeemable: cuando el ha validado el contrato del DA pero no la transacción del mismo.
 * Rejected: cuando el RP no ha validado la trasacción del DA ni el contrato del mismo.


= Funciones del Asset Issuing

El plugin Asset Issuing será el encargado de la creación de los Assets, incluyendo metadata y crypto monto, que posteriormente serán enviados a los posibles destinatarios de los Digital Assets. Este plugin
deberá solicitar la genesis transaction, la cual se define como la transacción origen de los crypto montos a ser transferidos junto al asset, así mismo, debe solicitar
la genesis address, la cual se define como la dirección que emitió el Asset. Una vez obtenida la información antes mencionada, este plugin debe crear las transacciones que
permitan la transferencia de los Assets a los destinatarios. Este plugin debe ser responsable de cada uno de los Assets generados hasta que todos hayan sido entregados a los
destinatarios. Este plugin debe tener la capacidad de monitorear que Asset ha sido entregado y registrarlo (aun no veo donde), para su posterior consumo. Si un asset no hasido registrado como entregado por este plugin, ese Asset no debería ser consumido por el beneficiario.
Estos Assets pueden ser enviados a cualquier tipo de wallet, es decir, debe ser transparente para este plugin los destinatarios de los assets, la metadata que se entrega a
 este plugin debe incluir la información que permita discriminar a que tipo de wallet/destinatario va dirigido el Asset, este proceso de filtrado podría tomarse de las wallets
 instaladas actualmente, este plugin debe recibir de una capa superior el criterio de selección de los destinatarios, de tal forma que este pueda crear la transación que permita
 enviar el asset al destinatario.
Los Assets que no se hayan enviado deben permanecer en el dispositivo emisor hasta que el beneficiario haya autorizado la instalación/descarga del digital asset
a su dispositivo. Al momento de instalación del Asset en el dispositivo destino es que se debe realizar la trasferencia del crypto monto al dispositivo destino.
Los crypto montos del emisor asociados a cada assets deben estar reservados en el dispositivo emisor hasta que sean transferidos a los beneficiarios. Estos montos no deben
cambiar una vez reservados.


= Transferencia y confirmación de Asset a beneficiario

= Notificación en Incoming Issuer

El plugin Incoming Issuer en el lado del consumidor o beneficiario será el encargado de monitorear la existencia de un Digital Asset (de alguna manera, por definir) que esté dirigido para la Asset Wallet del usuario,
en caso de recibir la notificación de la existencia de un Digital Asset, este plugin deberá verificar la metadata que debe estar incluida en el Asset,  esta comprobación debe
incluir la verificación de la genesis Transaction, con lo cual se puede verificar el origen del Asset.
Una vez verificado el origen del Asset, el plugin debe lanzará una notificación a una capa superior para que el usuario esté en cuenta de la existencia de este Asset.
Es de hacer notar que hasta el momento, se piensa que el usuario va a autorizar si el Asset va a ser descargado en el dispositivo, esto podría cambiar en un futuro,
ya que se plantea que este Asset puede estar "pre-instalado" en el dispositivo. Se podría definir varias posibles condiciones de descarga de un Asset:
 * descargable automáticamente (el Issuer la instala automáticamente en las Asset Wallets destino)
 * descargable por autorización del usuario.
 * preinstalada en la Asset Wallet.
Una vez que la Asset Wallet autoriza la instalación o descarga del Digital Asset, se procede a crear la transacción que va a transferir el monto crypto asociado a la metadata
de la genesis transaction a la Asset Vault del destinatario. Una vez realizada correctamente la transferencia de fondos, se debe notificar a las capas que controlan la UI la
correcta instalación/descarga del Asset.

*Preguntar al team*:
¿Un asset puede ser descargado o instalado por algún otro medio distinto a la red de fermat? ¿Se podría recibir vía código QR?

 = Transferencia y confirmación del Digital Asset a Redeem Point.

El proceso de transferencia de un Digital Asset a un Redeem Point es aquel en el cual el usuario va a canjear el DA por un servicio provisto por el emisor del asset (Issuer).
Este proceso incluye la participación del Plugin Outgoing Issuer en el dispositivo del beneficiario, el cual será el encargado de generar la trasacción que transferirá el DA
al Redeem Point. Este plugin, una vez culminada la creación de la transacción para realizar el envío del Digital Asset este debe modificar el estado del DA para que los siguientes
actores de la DAP procedan a notificar al usuario su consumo o su rechazo y su eliminación de la Asset Wallet.

#

:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 1
[[identityPublicKey-asset-issuer-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[identityPublicKey-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details


:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 1
[[actor-asset-issuer-BitDubai-V1]]
= Version 1

== Plug-in Description

.Relacionado al Asset User

1) Al iniciarse, solicita al Communication Server la lista de Asset Users que han notificado al servidor de su conexión.

2) Persiste en su base de datos aquellos nuevos Asset Users de los cuales no dispone registros conjuntamente con la dirección Bitcoin
de la Asset Vault.

3) Limpia de su base de datos, aquellos Asset Users que no se han conectado por ejemplo, en la última semana.

4) Actualiza la información de conexión con la fecha actual.

.Relacionado al Redeem Point

1) Al iniciarse, solicita al Communication Server la lista de Redeem Points que han notificado al servidor de su conexión.

2) Por cada Reedeem Point online al que no se haya comunicado anteriormente, solicitará a la Asset Vault la creación de una nueva rama en el árbol de claves HD.
Creada la nueva rama, la extended public Key (que permite la generación de claves públicas), será guardada en la RedeemPoint Address Book.

3) Transmitirá a través del communication server la clave pública para que sea guardada en el Redeem Point.
Cuando una transacción bitcoin ingrese de la rama generada por esta extended public key, se disparará el evento especifico para informar a la Asset Issuer Wallet que el Redeem Point dueño de
esa clave, redimió un asset.

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[actor-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

.Relacionado al Asset Issuer
1) Al iniciarse, notifica al Communication Server de su conexión.

2) Cuando recibe del communication Server el mensaje de registrar una nueva dirección de Bitcoin, valida que la propiedad NotifyBitcoinAddress
está en true y solicita una nueva dirección de Bitcoin a la Asset Vault a través del getBitcoinAddress y registra este pedido en CryptoAddressBook.


.Relacionado al Redeem Point
1) Al iniciarse, notifica al communication server de su conexión y ubicación.
2) Le solicita al Server los Redeem Points que están cerca. (definir "cerca").

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description
.Relacionado al Asset Issuer
El DAP Manager, al detectar que se ha instalado la RedeemPoint wallet, habilitará los componentes de este networkservice, que al iniciarse
se registrará con el communication server.

En un determinado momento, llegará una petición de comunicación a través del ActorNetworkService Issuer enviando una extended public Key para ser guardada
en la Redeem Point Address Book. De esta extended Public Key, el Redeem Point generará todas las claves públicas y activará a la CRypto Network para que escuche transacciones
de estas direcciones.

Llegada una transacción enviada a una de estas direcciones, se disparará un evento que generará el débito en la Asset User Wallet.

.Relacionado al Asset User
Al iniciarse debe conectarse con el communication Server y notificar su posición.
Si algún usuario está "cerca", recibirá la solicitud de brindar información del Redeem Point a través del communication server. Entre la información que estará pasando
al Asset User se encuentra la dirección de bitcoin generada a través de la clave pública.

== Plug-in Structure

== Events

== Implementation Details


:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 1
[[referencie-wallet-asset-issuer-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[referencie-wallet-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details


:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 1
[[wallet-module-asset-issuer-BitDubai-V1]]

== Version 1

El Modulo Asset Issuer implementara todo lo necesario para que permita creación del Asset, con toda la información necesaria para proceder enviar dicho Asset al User que tenga dicha Asset instalada, y de esa manera poder saber con exactitud
todas las transacciones relacionadas al Asset que el Issuer origino.

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details


:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 1
[[wallet-module-asset-issuer-BitDubai-V1]]
== Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details


:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 1
[[wallet-asset-issuer-BitDubai-V1]]
== Version 1
El componente asset issuer wallet registrara todas las transacciones contables que ocurran en la Reference Asset Issuer Wallet, y almacenara dicha transacción en la base de datos,
de esa manera el componente podra emitir todo los movimientos registrados en el Asset Issuer Wallet.
 Todas las transacciones deberan de pasar por el componente "Transacction" que sera en el que determine si la operacion debera ser persitida en la base de datos del componente asset
 issuer wallet.


== Plug-in Description
Se solicita a la Asset Vault una dirección bitcoin que será la GenesisAddress. Esta dirección solicitada queda registrada en el Address Book como solicitada por el Issue Actor,
la plataforma DAP y la vault de donde sale la dirección.
Definir en que momento quedara como disponible.

== Plug-in Structure

    fermat-dap-api===&gt;layer===&gt;dap_wallet===&gt;asset_issuer_wallet

== Events

== Implementation Details

    Se crearan las siguientes Interfaces:
      assetissuerwallet:
         Implementara todo el objeto que manipulara la información de la Asset.
            *Metodos sugeridos:*

            String getWalletPublicKey();
            String getDigitalAssetPublicKey();
            long getBalance()  throws CantCalculateBalanceException;
            void debit(); //Debemos de definir la estructura de la transaccion
            void credit(); //Debemos de definir la estructura de la transaccion

      assetissuerwalletmanager:
         Implementara la interfaz publica hacia los otros pluggins.

      dealswithassetissuerwallet:
         Implementara la Interfaz BitCoinWalletAssetManager para la interconexion hacia los otros pluggins.

      assetissuerwallettransaction:
         Implementara la interfaz para el registro de la transacción involucrada.

      assetissuerwalletsubsystem:
         Implementara la interfaz para el comportamiento del modulo.

:leveloffset: 1
[[wallet-asset-over-bitcoin-BitDubai-V1]]
== Version 1
    El componente Over Bitcoin Wallet registrara todas las transacciones contables que ocurran en la Reference Asset Wallet, y almacenara dicha transacción en la base de datos,
  de esa manera el componente podra emitir todo los movimientos registrados en el Asset Wallets.


== Plug-in Description

== Plug-in Structure

    fermat-dap-api===&gt;wallet===&gt;fermat-dap-plugin-wallet-asset-over-bitcoin-bitdubai

== Events

== Implementation Details

    Se crearan las siguientes Interfaces:
      bitcoinwalletasset:
         Implementara todo el objeto que manipulara la información de la Asset.

      bitCoinwalletassetmanager:
         Implementara la interfaz publica hacia los otros pluggins.

      dealswithbitcoinwalletassets:
         Implementara la Interfaz BitCoinWalletAssetManager para la interconexion hacia los otros pluggins.

      bitcoinwalletassettransaction:
         Implementara la interfaz para el registro de la transacción involucrada.

      bitcoinwalletassetsubsystem:
         Implementara la interfaz para el comportamiento del Pluggin.

:leveloffset: 1
[[wallet-asset-over-bitcoin-BitDubai-V1]]
== Version 1
    El componente Over Bitcoin Wallet registrara todas las transacciones contables que ocurran en la Reference Asset Wallet, y almacenara dicha transacción en la base de datos,
  de esa manera el componente podra emitir todo los movimientos registrados en el Asset Wallets.


== Plug-in Description

== Plug-in Structure

    fermat-dap-api===&gt;wallet===&gt;fermat-dap-plugin-wallet-asset-over-bitcoin-bitdubai

== Events

== Implementation Details

    Se crearan las siguientes Interfaces:
      bitcoinwalletasset:
         Implementara todo el objeto que manipulara la información de la Asset.

      bitCoinwalletassetmanager:
         Implementara la interfaz publica hacia los otros pluggins.

      dealswithbitcoinwalletassets:
         Implementara la Interfaz BitCoinWalletAssetManager para la interconexion hacia los otros pluggins.

      bitcoinwalletassettransaction:
         Implementara la interfaz para el registro de la transacción involucrada.

      bitcoinwalletassetsubsystem:
         Implementara la interfaz para el comportamiento del Pluggin.


:leveloffset: 1
= FERMAT-DAP /actor

:leveloffset: 1
[[wallet-module-asset-issuer-BitDubai-V1]]
== Version 1
    El Modulo Asset Issuer implementara todo lo necesario para que permita creación del Asset, con toda la información necesaria para proceder enviar dicho Asset al User que tenga dicha Asset instalada, y de esa manera poder saber con exactitud
todas las transacciones relacionadas al Asset que el Issuer origino.

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details

:leveloffset: 1
[[wallet-module-asset-user-BitDubai-V1]]
= Version 1

== Plug-in Description

== Plug-in Structure

== Events

== Implementation Details





:leveloffset: 0
== Iniciación en fermat sobre la plataforma Android

=== Comenzaré con una breve introduccion a la aplicación para que sepan cual será su ubicación dentro de Fermat.

Basicamente deberia comenzar con el concepto de wallet o cartera. Una Wallet es un applicación que en su version más simple nos permite enviar y recibir dinero. En este caso nos abocamos al intercambio de cryptocurrencies (por el momento Bitcoins).
A partir de este concepto podemos decir que lo que nosotros estamos construyendo es una fabrica de Wallet, las cuales derivan de una wallet padre llamada reference Wallet. Aquí es donde nos vamos a centrar en este momento en la capa de Android:
La reference Wallet posee 5 tabs en este momento, cada uno con una función especifica:

* Transaction: permite ver todas las transacciones realizadas, se hace una diferenciación por transacciones en Book balance y en Available balance
* Contacts:    permite ver un listado de contactos disponibles y posee un boton el cual permite el ingreso
* Send:        permite enviar bitcoins a un contacto o a una dirección de wallet desconocida por medio de su address
* Receive:     permite recibir bitcoins obteniendo una direccion para que otras wallet puedan enviar el dinero
* Balance:     permite ver el saldo disponible en el book balance y el availabe balance

Luego de los tabs en este momento se encuentra:

*  CreateContacts: pantalla que nace al hacer un click sobre el boton que se encuentra en el tab Contacts, como su nombre lo indica este fragmento se encarga de la creacion de los contactos

== Manejo de sesiones:
Uno de los problemas encontrados es la persistencia de datos en memoria ya que como conocen el ciclo de vida un fragmento al no estar visible se elimina y se vuelve a crear al llamarlo nuevamente. Estos datos deben estar guardados en algún lugar en caso de que el usuario quiera cambiar de wallet y dejar la sesion abierta, para resolver esto se implementó la creación de una sesión por cada wallet y un wallet manager que se encarga de la gestión de dichas sesiones teniendo así la posibilidad de regresar al momento en el que se encontraba el usuario al cambiar de pantalla.
El developer puede así persistir objetos en la sesión de cualquier tipo, dentro de un map que trabaja con una key y el objeto que el developer necesite guardar.

== Manejo de la estructura de navegación:
Como lo habrán notado Fermat es una aplicación distinta al resto de las aplicaciones android, posee una estructura de navegación propia. la cual se basa en pantallas y subPantallas que se van "pintando" desde objetos cargados en tiempo de ejecución , desde archivos, que entregan la información sobre que es lo que se necesita dibujar en cada pantalla/sub pantalla.
Para realizar esto a nivel de la Reference wallet hay un mecanismo implementado:

* Cada tipo de Wallet posee un Enum con los fragmentos, que se llama por medió de un Factory (en el core) y te dice que controladores se pueden "pintar" en pantalla, con esto quiero decir un identificador de la libreria a la cual debe ir a buscar los fragmentos (controladores) para la wallet. Los nombres de estos fragmentos deben estar en la estructura de navegación de la wallet para ser invocados.
* En la estructura de navegación tambien se pueden determinar tabs,colores,acciones, posiciones de las fragmentos a la hora de hacer el back, entre otras cosas.


= FERMAT: expanding the cryptoworld (the official book)

:leveloffset: 0
[[fbk-01 Welcome to FERMAT]]
== Welcome to FERMAT !

=== Beyond Bitcoin: FERMAT

((("fermat", id="ix_fbk-01-asciidoc0", range="startofrange")))((("fermat","defined")))
FERMAT is an inspired vision, a project to attain this vision, a group of pioneers of the software development industry working on it, a community supporting the core idea and providing the environment, and the whole world of potential users who will profit and be served by this.
FERMAT's vision is based on the huge potential of the blockchain transaction technology underlying the first sucessfully implemented cryptocurrency: Bitcoin. The undeniable goal of Bitcoin's crytographic based electronic signature protocol that builds a distributed public ledger of peer-to-peer electronic transactions opens the door to a new paradigma in economics, computer science, financial operations, and world-wide commerce. Sakamoto's invention makes possible to unveil the world of financial transactions, to get rid of the necessity of trust into a third party institution or central goverments, to make money a secure thing, and transactions transparent and effortless, giving back the absolute control to the money's owner. The cryptocurrency scheme encourages us to adopt a radical new point of view on money and the concept fo value itself and its transport, so radical, that it will take us some time and effort to really grasp it, because it leads to unconditionally honoring and empowering of each individual.
FERMAT as a project is also a big challenge to the open source software industry because it firmly believes that the comunnity has much more talent and intelligent collectively than isolated individuals, and the project is inscribed in the wolrd-wide cryptoindustry ecosystem with the conviction of laying the seeds of a global collaborative endeavourw ith a firm call to commited collaboration from peers and colleagues.
FERMAT from its conception is addressed to pioneers, and we have already engaged a solid core of software developers that is working in shaping the first version of the platform to be soon released.

FERMAT is, technically speaking , an Open Source P2P (Peer-to-Peer) System built on a Plug-in Architecture running on end-user's devices. The first goal is to get very close to the end user offering and easy way of coming onboard the crytocurrency world by means of and insutitively easy to access cryptocurrency Wallet. At the same time, the open source plug-in platform allow any skilled actor in the community to jump in and develop applications and offering services with different abstractin levels and addressing a wide range of segmented markets. In fact, FERMAT as whole sets a common ground, a kind of "Master Plan" for developing wallets, wallet services, p2p network services and all kind of future develpments based in blockchain tech, using the existent global talent and intelligence that the community already has and collaborating with very intense feedback in expanding this technology to reach rapidily end user's mass adoption, giving all the participants in the different sectors a sense of trust, safety and equity, and the corresponding right to become a revenue for each one's contribution and effort.
Instead of begginning a new project in this industry completley from zero point, the clear and firm logic of FERMAT can turn it to become a new standard in the industry by giving the collective a group coherence as it had never before, and encourages to grow safely in a collaborative way.

.Challenges and opportunities: inspiration from Fermat's Last Theorem
****

((("bitcoin","precursors to")))
---------------------
As you may have noticed, the entire project has been named following the famous mathematical puzzle that haunted generations of mathemathicians until it was finally proven after 350 years. (if you are courious about the whole story, see http: ....    ).
It is so because this project was born when trying to solve the new questions, issues and puzzles that the genious Sakamoto's solution to an old cryptographic called , which let him consolidet the foundation of Bitcoin, the first sucessfull cryptocurrency. (for a wonderful detailed introduction to Bitcoin's world, please refer to the "must read"excellent book of Antonio Papadopoulos "Mastering Bitcoin").

The "puzzle"to solve in the emerging field of blockchain tecnology is related to finding the answers to the following questions:

* How can we isolate ordinary people from the perceived complexity?
* How can we use the collective intelligence of the developer community?
* How can we reuse the entire current infrastructure already in place?
* How do we integrate legacy financial institutions in a way they feel comfortable?
* How do we integrate merchants, retailers and brands of all sizes in a clever way?

The answers to each of these questions are addressed within the FERMAT platform.
****

=== FERMAT's Mission:

&gt; Empower every person in the world with the appropriate tools to save and move their money in a digital format in an efficient, secure an private way. And at the same time allow them to choose which currency to use, regardless of the place they live or where they were born.


=== What makes FERMAT different from other wallet platforms or services?

* **FERMAT is P2P.** This makes it censorship resistent and difficult to be attacked.

* **FERMAT is built with plugins.** This enables functionality to be reused and opens the door to any developer to participate.

* **FERMAT runs on end users' devices.** This enables users to hold their own money eliminating the need to trust a third party.

* **FERMAT is inclusive.** By creating their own plugins, current industry members can integrate with FERMAT to offer their services and products to FERMAT user base.

* **FERMAT segments the world population and offers a custom tailored solution for each segment.** Any developer can easily create niche wallets for a particular group of people. Brands can create their own wallets for their followers. All the heavy lifting is done by the FERMAT platform.

* **FERMAT guaratees plugins and wallet developers a revenue stream.** FERMAT implements an innovative business model which allows plugins and wallet developers to define a use license, and FERMAT itself enforces this license on behalf of developers. )



=== FERMAT's Principles

==== 1. FERMAT should not allow censorship.
* Open Source.
* P2P architecture.

#### 2. FERMAT should not allow spying on their user base.


* Point to point encrypted communications.
* Geofenced P2P network enabling the shortest communication path between peers.
* Multi-technology communication layer (cloud, p2p, wifi, bluetooth, nfc, mesh, etc.).


#### 3. FERMAT should be secure and resistant to all kind of attacks.


* No centralized point to be attacked.
* Multiple identities and roles per user.
* Device Private Network (DPN) concept.
* Pocket Money concept and a Multi-Signature Vault owned by the DPN.
* Reviews and Reputation concepts.


#### 4. FERMAT should never loose a user's funds.


* Transaction responsability transmission protocols.
* Remote technical support by wallet and plugins developers.


#### 5. FERMAT should be usefull to each segment of the world population.


* Niche wallets concept.
* Branded wallets concept.


#### 6. FERMAT should be extensible and open to innovation.


* Plugins architecture.
* Multi dimensional layer architecture.


#### 7. FERMAT should be open and inclusive.


* Any developer could contribute to the shared infraestructure.
* Any developer could write code for new plugins.
* Any developer could write code for new niche wallets.
* Any developer could fork an existing niche wallet to further specialize it.
* Any graphic / UX designer could provide skins to existing wallets.
* Anyone could provide language packs to existing wallets.


#### 8. Each developer should be compesated by their contribution to FERMAT.


* Micro license concept.
* Micro license structure concept.
* FERMAT automatically enforcing license agreements.
* Plugin ownership concept.
* Niche wallet ownership concept.
* Branded wallet onwnership concept.
* Master plan design comcept, wiht no overlaping functionality but shared ownership.


#### 9. FERMAT user base should be a shared asset.


* Any developer should be able to profit from the growing FERMAT user base by writing Plugins this user base could consume via the developers of the wallets they are using.


#### 10. FERMAT should be inclusive with crypto currency industry members.

* Any bitcoin | crypto | blockchain established startup could write their own plugins and expose their services to both FERMAT developers and the FERMAT user base.
* Any alt-coin community could write plugins to enable their crypto currency within the FERMAT wallet ecosystem.


#### 11. FERMAT should be inclusive with the current financial system.


* Banks and financial institutions could write plugins to enable FERMAT wallets hold funds in banks and other financial institutions.

* FERMAT allows it users to move money both through public value transport networks as crypto currency networks and also thwough private or legacy financial networks.


#### 12. FERMAT should be unbanked-people friendly.


* Multiple logins per device (Device user concept)
* Crypto banking concept.


#### 13. FERMAT should be OS agnostic.


* OSA layer concept (Operative System API).
* OS dependent UI on top of FERMAT concept.


#### 14. FERMAT should learn from its user base.


* Integrated feedback functionality.
* Voting over feature wish-lists concept.


#### 15. FERMAT should be the finacially most efficient way to move or spend the end user's money.


* Crypto Vault for multiple wallets concept.
* Financial AI Agents concept.


#### 16. FERMAT should facilitate the regional distribution and access to crypto currencies.


* Crypto Distribution Network concept.
* Crypto Brokers concept.


</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-09-28 10:58:02 ART
</div>
</div>
</body>
</html>